<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[苹果开发者账号导出证书]]></title>
    <url>%2F2023%2F09%2F13%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[登陆 开发者平台 进入证书链接 创建bundle id 进入Identifiers菜单界面，点击加号 选择app ids，下一步 选择app，下一步 Description可以随便写，Bundle ID选择Explicit，填写的内容必须是全局唯一的，类似com.domainname.appname 这种格式，然后下一步 点击注册即可 创建csr文件 在Mac电脑，点击钥匙串访问-证书助理-从证书颁发机构请求证书 填写电子邮件及常用名称，选择存储到磁盘，点击继续 点击完成则创建请求文件成功，然后在Finder中找到文件位置，方便后面使用 申请开发者证书 开发者页面上面选择Certificates，点击加号 选择Apple Development，下一步 选择刚刚从钥匙串上面生成的文件，下一步 下载证书，双击添加到钥匙串。这里需要注意的是，钥匙串的左边菜单要选择登陆，不然导入一直报错 选中导入的证书，然后右键导出，文件格式选择p12 创建描述文件 开发者页面选择Profiles菜单，点击加号 选择ios app development，下一步 选择app id，也就是上面创建的bundle id，下一步 选择证书，下一步 选择设备，全选比较方便，下一步 输入文件名，生成就可以了]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setapp使用推荐]]></title>
    <url>%2F2021%2F12%2F01%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fsetapp%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E8%8D%90app%2F</url>
    <content type="text"><![CDATA[setapp使用步骤 setapp是用在macos系统上的一个集成app的软件，可以理解成是一个新的app store，里面有很多付费软件，可以直接使用 注册/管理帐号 在https://setapp.com/上注册帐号 如果是个人付费帐号，那么直接登录到自己电脑上的setapp上面就好了 如果加入的是家庭版（更划算一些，￥200/y），将注册的邮箱发给家庭版的主帐号，添加到家庭中 下载setapp到mac电脑上 在https://setapp.com/download下载setapp，安装到电脑商 登录进自己的帐号（一个帐号就只能使用在一台机器上） 值得使用的app cleanmymac是一个维护自己电脑设备的，可以用来卸载软件，更新软件，维护开机启动项等等功能，必备 istat 是一个专门查看电脑使用状况的软件，必备 bartender是一个管理电脑menu bar的小工具，必备 timing是一个用来查看用户使用电脑状况的工具，可安装 moneywiz是最好的一个记账工具，可以在iPhone上使用，同样免费，可安装 ulysses，macos上最好（最贵）的写作设备，可安装 marginNote，macos上学习工具最好的一款]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx的参数转发]]></title>
    <url>%2F2021%2F06%2F16%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fnginx%E9%80%9A%E8%BF%87header%E5%8F%82%E6%95%B0%E6%9D%A5%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E5%88%B0%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[通过header参数来转发不同域名 最近有遇到，需要通过判断前端输入的参数不同，来转发这次请求到不同底层服务上去，这里通过设置一个header参数来判断 123456789101112131415underscores_in_headers on;location /api/gateway &#123; if ($request_method = OPTIONS ) &#123; return 204; &#125; set $xhost $host; if ($http_gwenv = 'rd') &#123; set $xhost "xxx1.domain.com"; proxy_pass http://xxx1.domain.com; &#125; if ($http_gwenv = 'mid') &#123; set $xhost "xxx2.domain.com"; proxy_pass http://xxx2.domain.com; &#125; proxy_set_header Host $xhost underscores_in_headers on nginx是支持读取非nginx标准的用户自定义header的，但是需要在http或者server下开启header的下划线支持 proxy_set_header不能直接作用于if语句块中，这里通过设置一个变量，然后在外面来解决 nginx的语法中，也没有if…else…的语法，直接使用单个if语句块即可 获取自定义的header参数，在server中应该是$server_xxx，在http中使用$http_xxx来获取参数，并且都是小写]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的一些提高运行速度的tips]]></title>
    <url>%2F2021%2F06%2F01%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E6%8F%90%E9%AB%98%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E7%9A%84tips%2F</url>
    <content type="text"><![CDATA[python提高运行速度的几个提式 尽量使用内置的方法 1234567# bad onenewlist = []for word in wordlist: newlist.append(word.upper())# betternewlist = map(str.upper, wordlist) 使用列表生成式来替换循环生成的语句 1234567# bad oneeven = []for i in range(1000): if i % 2 == 0: even.append(i)# better oneeven = [i for i in range(1000) if i % 2 == 0] 使用join方法来替换+，字符串的连结 1234# bad oneIdendity = "I'm" + "a" + "Programmer"# better oneIdentity = " ".join(["I'm", "a", "Programmer"]) 使用1来替换True实现死循环的操作，可以减少部分的比对消耗 1234567# bad onewhile True: print("hello") # better onewhile 1: print("hello") 多个参数的定义 123456# bad onea = 'test'b = 'test2'# better onea, b = 'test', 'test2' 更多的使用C模块，例如Numpy这种完全用c写的模块，性能非常好 升级python的版本 引入模块的时候，尽量使用from...import...的方式，来避免引入整个包]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的一些方便配置以及修改历史信息]]></title>
    <url>%2F2021%2F03%2F04%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E4%BA%BA%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%9B%AE%E5%BD%95%E7%9A%84git%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[根据不同环境来自动变更git的设置 从git的2.13版本开始，提供了includeIf字段来区分不同的git config文件这样做的好处在于，可以区分个人项目和公司项目，配置不同的提交人信息 在home目录下建.gitconfig文件，代表全局配置的，这里面不要写user的字段信息，这部分信息由其他文件提供 在其余目录生成个人或者公司项目的配置文件，可以随便取名 设置includeIf的字段信息，配置不同的文件 1234567891011121314151617# 主要的.gitconfig内容，具体路径的问题可以修改，指向不同的目录，path指向也可以指向不同目录下的文件，相对路径和绝对路径都可以[includeIf "gitdir:~/work/personal/"] path = .gitconfig-personal[includeIf "gitdir:~/work/github/"] path = .gitconfig-github...# .gitconfig-personal文件内容[user] name = xxx email = xxx@xxx.com # .gitconfig-github文件内容[user] name = xxx2 email = xxx2@xxx2.com 修改以前的提交信息 直接在需要修改的git库下执行即可，然后执行git push --force 1234567891011121314151617#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="old-email@email.com"CORRECT_NAME="xxx"CORRECT_EMAIL="xxx@new-email.com"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi' HEAD 这里HEAD代表所有提交记录 gitlab的提交权限问题 以上修改完后，需要强行覆盖到远程分支上，这里需要注意的是，如果提交的分支是收到保护的分支，那么会报错 1234remote: GitLab: You are not allowed to force push code to a protected branch on this project.To gitlab.dmall.com:devops/cloud-gateway.git ! [remote rejected] master -&gt; master (pre-receive hook declined)error: failed to push some refs to &apos;git@gitlab.dmall.com:devops/cloud-gateway.git&apos; 可以在gitlab上把这个git库的分支受保护关掉 具体可以在gitlab上查看，repository-&gt;Branches-&gt;projects settings-&gt;Protected Branch-&gt;关闭当前分支]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信用卡权益使用]]></title>
    <url>%2F2020%2F12%2F03%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%9D%83%E7%9B%8A%2F</url>
    <content type="text"><![CDATA[信用卡权益交行白麒麟 附属卡免基本年费，而且最多可以免3张。这就意味着付1份年费，享受4张卡的权益白麒麟单卡有6次CIP+6次龙腾贵宾厅，如果配合3张附属卡，那么可以达到惊人的24次CIP+24次龙腾贵宾厅。 6次龙腾机场贵宾厅（附属卡同有） 6次沃德贵宾厅（附属卡同有） 6次50公里内酒后代驾 延误险，2小时最多1000元（附属卡同有） 意外险，最高1000万 生日当月可享双倍积分，上限100万分（附属卡同有，需要在主卡生日当月刷，积分奖励合并） 生日当天餐饮娱乐类消费5倍积分，上限10万（附属卡同有，需要在主卡生日当天刷，积分奖励合并） 招行经典白 主卡1w积分兑换，附属卡5000积分兑换 主卡和附属卡每年每卡1人的体检和洗牙服务 主卡/附属卡均可免费使用6次招行机场贵宾厅，同时可带6人进招行贵宾厅。招行机场贵宾厅一般是自己冠名或者合作贵宾室，不同机场的条件差异比较大，配合龙腾/PP卡使用会更好。 每年 4 次精品酒店300 元+100积分入住权益。每年4月1日到次年3月31日，可用300元+100积分兑换4晚精品酒店入住权益，需提前在招行出行易或致电客服预定 每卡每年有12次高尔夫练习场，可以100元+100积分换1次果岭（每户每年有6次） 航空意外险：高达1500万的航空意外险；航班延误险：航班延误4小时赔付2000元（需使用经典白购票）。 邮储鼎致白 20w积分兑换年费 龙腾机场/高铁贵宾厅服务 6点 龙腾机场/高铁站接送车 6次 专家号预约及陪同服务 6次 口腔护理 1次 每年可免费享受6次室内网球或五星级酒店游泳健身服务 1小时羽毛球/健身/游泳 6次 道路救援 无限次 年检待办 1次 每年可免费享受6次酒后代驾服务 cip通道服务 6次]]></content>
      <tags>
        <tag>信用卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读搞定一书，记录笔记]]></title>
    <url>%2F2020%2F09%2F13%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%90%9E%E5%AE%9A-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[清除杂念，保持清净，适当反应 目标就是排除大多数的思考，这些思考会扰乱你当前的任务精力，不能让你全身心投入进去 思考结果是促使希望转化为现实的最有效手段 大脑会不由自主的记录所有待解决的事情，但却不会给你适当的提醒，反而会给你希望思考的其他事情带来干扰，减低你的工作效率 成功收集的三要素 每一件悬而未决的事情都应该保存在收集系统中，不能过多占用大脑的精力来回忆 控制收集工具的数量，越少越好 必须定时清空这些收集到的事项 理清事项 收集工具中的事项有些数据并不完整，需要分析，判断是否是一个可以执行的步骤 不采取行动的事情 直接删除 日后可能会用到，那就存放到备忘录中 需要行动 判断是否需要一系列的行动才能完成，这就是项目 立即执行 指派他人 延迟处理 利用下一步清单来替换每日清单 由于现在的工作中会不断产生新的问题，工作的重点也会变化，那么每天的工作安排也就不一定能提前确定，对于，更好的方式是确保下一步清单，下一步清单中就代表了立马需要做的 日程表的作用就是、如果一旦标记，那么就认为这个动作必须在这个时间点完成，其他时间点无法完成 如果一个任务没有特定的时间段，那么就不要放入日程表中 组织整理系统清单 用作回顾 项目清单 日程表 下一步清单 等待处理清单 完成任务的步骤 定义目标和原则 展望结果 头脑风暴 组织整理 明确下一步的行动方案 要完成收集，理清，组织，回顾这一套完整的流程 确认，收集你能想到的所有一切，并整理清楚，清空大脑 更新，回顾下一步清单，日程表数据，即将到来的日程，回顾等待清单，回顾项目清单，回顾核查清单 创新，回顾将来清单，也许当时的任务已经不适合当下，收集平时的奇思妙想 在某些时候，你必须要搞清楚你的宏观目的，长期目标，以及从根本上对你的决定起推动，评估和排序作用的愿景和原则 确定某一时刻具体行动的四个标准 情境，身处的位置，手上的工具 有多少时间 有多少精力 重要性 面对意外出现的工作，一定要冷静考虑清楚它是否值得你停下手上的工作我，千万不要为了忙碌而忙碌 三个关键原则 养成收集的习惯 确定下一步行动 学会关注结果，找到目标，确定行动 将大量的信息，观点，主意结合在一起，并进行合理的统筹安排，是新世纪人才的一项重要能力 心理资本 自我效能，付诸行动并投入必要努力以及成功应对挑战任务的信心 乐观，现在和未来获得成功的积极因素 希望，坚持目标，并在必要的时候重新定向实现这些目标的路线 韧性，在摆脱困境或者解决问题之后恢复乃至于改善原始状态 精通gtd的三个阶段 采用最基本的工作流程管理 执行一个较为高级和综合的全方位生活管理系统 利用技能创造明确的空间，完成任务，并且使你的表现越来越得体]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读flask源码笔记]]></title>
    <url>%2F2020%2F09%2F09%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E7%AE%80%E5%8D%95%E9%98%85%E8%AF%BBflask%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[阅读flask源码globals.py 定义线程变量的文件 这里使用了werkzeug模块的Local， LocalStack， LocalProxy Local可以理解为创建了一个dict，key就是线程的id，这样每个线程就可以通过自己的id访问自己的数据 LocalStack是利用了Local实现的一个栈结构，每个线程的数据就是一个数组，实现了多线程隔离 LocalProxy最初是用于为Local为创建一个代理对象，对此代理对象执行的任意操作与直接对Local对象执行操作等价。之后，LocalProxy可以为方法创建代码对象，对此代理对象执行的任意操作与对被代理方法的返回值执行操作等价。这样做的好处是可以实时获取到最新的值 current_app, request, session, g都是在这里定义的 config.py 定义读取配置的方法 读取配置文件的类就是config 方法主要是通过from_object, from_mapping这三个方法 最主要的就是将文件内容转化为obj型数据 json文件夹 init.py 这个文件夹主要是用来编码/解码数据用的，尤其是返回给客户端的response，解析客户端过来的request数据等客户端发过来的请求数据，一般都是json的数据，返回去的数据也是json，因此，需要一个转json的方法来处理有一些涉及到需要转码的方法，例如需要将html无法识别的特殊字符转化的方法也在这文件中 tag.py 这个文件定义了一系列方法，用来解析不规则的一些文件，字符等。例如html语言的文本，python中的tuple， list， dict helpers.py 这个文件定义了很多辅助方法，重要的有以下几个 send_file方法定义了，需要返回客户端一个文件 flash方法，定义了上一个请求中存储的信息，下一个请求可以使用 url_for方法，根据后缀找到blueprint中定义好的路由 make_response方法，定义返回请求的数据 get_env获取应用启动时的环境参数 signals.py 这个文件定义了框架中一系列的信号，用作后期的通信，例如request_tearing_down这种都在里面，里面并没有定义额外的方法，都是使用的blinker模块的Namespace自带的 和hook的差别，主要在于hook函数支持abort，signal不支持；hook不支持额外的参数，而signal支持 templating.py 这个文件主要是定义了渲染的一系列方法使用了jinja2模块的方法，并从全局变量中获取对象，然后在具体的模板中注入对象值 views.py 文件主要定义了视图类的方法，以及请求的方法定义 注重定义了一个as_view的方法，可以将定义的类转化为多个请求实例，根据请求的method不同，而转向不同的方法函数，减少重复的代码 MethodView类，处理请求的method，将之绑定到对应的响应方法上去‘ logging.py 使用logging模块，封装了一层，专用来返回log的handler，并保证线程安全 scaffold.py 定义了一些hooks，包括before_request, after_request等等在flask框架中，直接使用该装饰起就可以注册到app实例中执行 从route方法中可以直接看到，通过app.route()注册的路由方法，实际上还是调用的app.add_url_rule()的方法，因此，这两个方法并没有区别 其中endpoint方法，主要是提供给url_for来实现路由跳转的，url_for(endpoint) sessions.py 这个文件主要是定义了会话和cookie的一系列操作 flask中使用的会话都是加密的 框架中不直接使用cookie，框架已经将cookie转化为了cookie，再回调客户端的时候，再将session转化为cookie 如果cookie已经被修改过了， 那么会直接删除 debughelper.py 用作开启debug模式的一些提示 ctx.py flask中的上下文定义包含了appcontext，requestcontext g对象是绑定在request context上的 这两个对象都是利用了线程栈的数据结构来操作数据 app.py 这个文件用来定义flask完整类引入了flask模块中的其他依赖模块，函数，全局定义等 定义了多个特性，带有@propery装饰器的部分 定义了多个实现方法，带有@setupmethod blueprints.py 定义路由的文件 从Scaffold继承而来，因此，在路由层面可以直接引用各种hooks register方法就是用来注册所有视图方法以及回调，和app绑定到一起]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐certbot申请ssl证书]]></title>
    <url>%2F2020%2F09%2F03%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fcertbot%E5%AE%89%E8%A3%85ssl%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[使用certbot来更新网站证书 certbot是Let’s Encrypt官网推荐的更新证书的方式，今天在机器上安装尝试了下，确实方便了很多，但安装的时候，也遇到了一些问题，这里简单记录下 安装 本机系统centos7 由于使用了全局的pyenv，设置了3.6的环境，而certbot是2.7，因此，需要先将python的版本切换回去，否则会报错 pyenv local system切换回版本，如果还是报错，那么重新安装urllib3模块即可 如果openssl版本太老，也需要重新安装，报错 解决办法，直接重新安装 rpm -Uvh http://cbs.centos.org/kojifiles/packages/pyOpenSSL/0.15.1/1.el7/noarch/pyOpenSSL-0.15.1-1.el7.noarch.rpm 安装证书 由于网站都是通过nginx代理的，所以执行certbot选择nginx即可 执行命令 certbot --nginx 这里最好是使用yum的方式安装nginx，因为certbot会去访问/etc目录下的nginx目录配置文件，然后将涉及到的域名都捕获出来，开始提示用户选择申请 接下来按照提示，一步步做就行了]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读奇特的一生的感想]]></title>
    <url>%2F2020%2F08%2F31%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E5%A5%87%E7%89%B9%E7%9A%84%E4%B8%80%E7%94%9F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[奇特的一生-读后感 与其说这是一个介绍时间管理的工具书，不如说是一个人物的传记。书中通过对柳比歇夫的日常，日记，生活，思维方式等不同维度分析，叙述事实，通过一些小细节试图表达柳比歇夫这个人的人生哲学，然后，通过这些他自己的感悟，来描绘出为什么他要发明这个时间管理法，利用这个，他获得了什么？这是一本值得多读多想的书，里面很多的人生态度都值得后人学习。 坚持才是最大的问题 有规律的生活也能保证精神充沛的状态 培养良好的自律性前提就是已经存在一个你愿意为之奋斗的目标，这个目标是的你愿意为此付出巨大的精力和时间，让你无法让我一丝一毫的浪费时间 切割伟大的目标到每天的小任务，你会发现每天都离目标更近了一步，这样有助于提高动力 大多数人每天的有效工作时间都是不够2小时的，那么给自己制定一个目标，当你这一天的有效工作时间超过了两小时，那么就认为今天完成了工作进度，如果不够，那么就被认为未达标 从一个更宏观的角度来看待时间管理框架 不管是手记还是通过软件，目的只有一个，那就是按照你的时间来划分清单，将每天的时间分成块状，将预计到的事情填入进去，就像小时日历一样 随着时间的变化，一天的排期已经不能满足你的需求，可以将一天改为一周，一年，五年等 从一个更宏观的角度去理解时间管理，将一个5年期的目标拆成具体的任务，你会发现每天都在向目标靠近，很有成就感 忙碌的工作和享受生活没有冲突 越忙碌的状态，更需要工作之外的活动来排解压力，让自己获得能量来继续投入工作 提高工作的效率，远比一直用大量的时间来堆砌干活更好，这需要大量的训练，才能养成 时间管理最高的境界就是，你总是可以浪费一些时间去做没有什么目的的事情，只要你开心，没有负罪感，你就是一个幸福的人 时间统计办法和其他时间管理的不同处 时间统计法相较于其他时间管理办法，最大的特色是根据每个人的实际情况来找到自己的行为模式，从而把时间聚焦到能力和目标上，有系统，反思，优化地使用 使用投入产出比来提高生活质量，对于不同的人来说，对于时间的产出也不一样，因此，按照个人的定义，来优化某一项的时间投入，如果这一项投入太大，产出很小，就应该优化它 时间统计办法的优点 最重要的一点就是可以清晰的认识到自己每天花费了多少时间在什么任务上 每周月统计一次，做成报表，会更加清晰明了，养成习惯以后，可以针对下一阶段的任务作出预估 记录数据，最重要的当然就是统计汇总，得出结论，看是否达到了预计的目标，如果有拖延，也能清晰认识到是什么导致了拖延]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决一个el-input框无法强制更新的问题]]></title>
    <url>%2F2020%2F08%2F28%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E8%A7%A3%E5%86%B3el-input%E6%A1%86%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[el-input无法编辑 在form表单中，定义了一个input框，双向绑定了一个值，但发现无法在页面上对input框进行任何修改，即使输入了新的值，离开了input框发现又变回原样了，因此，只能使用forceUpdate方法来解决 123456789 &lt;el-form-item label="关联域名" prop="domain_prefix"&gt; &lt;el-input v-model="deployJobForm.domain_prefix" clearable style="width: 95%" @input="modifyDomain"&gt;&lt;/el-input&gt; &lt;span style="width: 5%;padding-left: 10px"&gt;.&lt;/span&gt; ... modifyDomain () &#123; this.$forceUpdate() &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的数据库模型框架sqlalchemy中使用的部分技巧]]></title>
    <url>%2F2020%2F08%2F28%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fsqlalchemy%E9%92%88%E5%AF%B9%E7%A9%BA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python-sqlalchemy针对数据库中null和空值的筛选 使用XX.isnot(None)只能筛选出是null的值，如果这个值有可能是空和null，那么需要将null转为空，然后再判断筛选 123query_hosts = db.session.query(HostList)\ .filter(func.coalesce(HostList.project_code, '') == '', func.coalesce(HostList.module_code, '') == '', sqlalchemy的模型中的默认值 在model文件中，定义字段为created = Column(db.DateTime, nullable=False, default=datetime.now)，那么当值为空的时候，为默认添加当前时间的值，可以不需要继续在数据库中针对该字段来设置默认值了]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读你的灯还亮着吗后，记录下读书笔记]]></title>
    <url>%2F2020%2F08%2F25%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E4%BD%A0%E7%9A%84%E7%81%AF%E8%BF%98%E4%BA%AE%E7%9D%80%E5%90%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题是什么 不同的人思考问题的解决方案都不一样，换句话说，对于来说是一个问题，或许对于他人来说就不再是问题 问题就是理想状态和现实状态的差距 问题的定义是否正确 即使问题已经解决，你也无法确定问题的定义是正确的，或许原本的问题并不是你所想的 你可以永远无法确定问题的真正定义，但不应该放弃去寻找真正的问题定义 真正的发现问题 一个解决方案往往会带来新的问题 如果针对解决方案没有想到3个以上有可能出错的地方玩，那么就代表你没理解真正的问题所在 对于一个问题，不同的人会有不同视角，多咨询了解别人的看法，会给你一些新的思路 需要不时的回头看看，查找问题的方式以及问题的定义是否已经偏离了预定的目标 谁来解决问题 当别人可以妥善解决他自己的问题时，不要插手，这样做更能激发他自己的主观能动性，如果旁人插手，会造成别人的反感 如果一人处于解决问题的位置，但是他又感受不到问题的困扰，那么就想办法让他亲身体验到这个问题 问题来自哪里 大部分的问题都来自于自身，某些问题的出现，如果能换个解读问题的方式，从自身出发，或许是一个解决问题的方案 世界上有两种人，一种人做事，一种人制作出事情来让人做。远离那些找事的人，做第一种人，那里的争斗比较少 谁来解决问题 对于解决问题的人来说，最难的是你以为那些问题的所在人知道该问题，但实际上他却不知道，或者说为了某种目的忽略掉了这个问题 真正想要解决问题的人并不是很多，很多问题正因为他存在，所以才会有人一直来解决，或者这算是增加了就业率？ 并不是所有的问题都值得花费时间和精力去解决 习惯化能让人们忽略环境中恒定不变的东西，从而简化自己的生活]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡眠革命读书笔记]]></title>
    <url>%2F2020%2F08%2F14%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[晚睡人和早起人 晚睡并不代表懒，而是身体的构造引起的。日光是最好的调节器，晚睡的人早上起来可以晒一会太阳，刺激身体激素，更快的适应不同睡眠节奏的人，可以互相配合达到协调的目的，早起的人在晚上精力差，不适合夜班，晚睡的人恰好相反，这是可以互补的 睡眠周期更加重要 一个完整的睡眠周期大概是一个半小时，90分钟 打瞌睡阶段，容易被外界干扰，很容易醒来，一旦醒来需要重复进入睡眠的完整过程 浅睡眠状态，这个时期也是容易被外界干扰导致醒来然后重新开始睡眠循环的 深睡眠状态，这个时间段是比较重要的，身体会开始修复，大脑开始整合信息，不太容易被外界干扰导致醒来 快速眼动状态，这个时候做梦是最多的，也更加容易激发创造力 以上四个就代表了一个完整的r90睡眠循环 不要太过于纠结每天睡了多少时间，而是应该把时间放宽，比如每周完成了多少个完整的睡眠周期大多数人每周35个睡眠周期，但这并不是绝对的，只好保持住26-30个睡眠周期也是完全可以接受的需要注意的是，应该养成每天固定时间起床的习惯，一般来说，工作前90分钟起床是比较好的建议 睡眠前后的一段时间至关重要 实际上，在睡眠开始前以及醒来后的一段时间，也应当放入睡眠周期之内，这两部分对于晚上的睡眠质量也是至关重要的在睡觉之前，放空大脑，避免睡觉的时候想东想西，冥想是个不错的选择。提前一个小时喝完水，减少电子产品的蓝光照射，可以在这段时间准备下第二天的东西，但不涉及工作上的信息醒来后的这段时间，应当留下一部分时间，不要着急做某些事情，而是慢慢的适应当天的生活节奏，煮早饭，简单锻炼下，沐浴阳光，这样都对当天的状态会更好即使周末想睡懒觉，也可以在固定的时间起开，做一些小事，比如吃个早饭，然后再继续上床休息，这样会更好 白天的睡眠优点 晚上的周期r90睡眠，是最好的改善大脑和身体疲劳的方式，但如果晚上的睡眠质量不高，那么白天也是有时间来做一下补充的午睡是第一个好时机，在1点到3点，能有半小时左右的时间，即使没有睡着，也能对大脑消除疲劳起到帮助，并且对接下来的下午工作，集中注意力更有帮助另外一个时间点就是下午的5点到7点间，这段时间的睡眠需求达到了顶峰，如果有时间，那么也可以小睡一会需要注意点的就是，白天的睡眠仅仅是对晚间睡眠的补充，因此不能按照晚上的睡眠周期来施行，一般来说半个小时足够了，也不需要上床休息，就在位置上打个盹就好了工作中不可能时时刻刻集中注意力，需要时刻注意休息，这样也是一种调节大脑疲劳值的方法 睡姿和寝具 良好的睡姿是保证睡眠质量的一大要素，侧卧是相对来说组好的睡姿，偏向于非常用身体的一面更合适寝具的购买主要来自于床垫，尺寸是卖越大的越好，可以增加舒适度，良好的床垫应该让人侧卧睡着更舒服，如果床垫不够适用，那么可以在床垫上增加一层薄的无过敏材料，透气的床垫，这样会让人感觉更舒适 睡眠环境 睡眠环境的重要性和寝具类似的，它应该是一个只提供睡眠的环境，因此，电子设备尽量不要放入卧室中保持卧室的清洁，窗帘厚一些，隔音效果尽量好点，卧室可以保留能带给你安全感的一切物品 特殊场景下的例案入睡难，半夜中途经常醒来 可以尝试用睡眠抑制的办法来试试，这个办法就是将你原有的睡眠周期缩短，比如你每晚上只睡5个睡眠周期，那你就缩短为4个，如果依然还有以上问题，那么再尝试缩短为3个等实际上，我们只是把你躺在床上翻来覆去睡不着的时间拿出来，让你继续做其他的事情，长时间处于浅睡眠周期很容易被打断，这个时候还不如起床干其他的这个时候需要你利用好白天的睡眠补充周期，这个时候的补充对于你的身体也能起到很好的作用 上班日夜颠倒 依然利用好r90的周期方法，上完夜班回到家不要立即睡觉，可以帮他当成晚上，吃个早餐作为晚饭，然后和家人聊一聊，在中午12点半开始入睡最好，直到下午的6点半，4个睡眠周期晚上上班，打瞌睡的时候，可以呆在日光灯下，玩蓝光设备，喝咖啡等一切有助于保持清醒的方法，这样会帮助你白天的睡眠质量更好 伴侣以及新生儿 当不再是一个人睡的时候，要想要保证睡眠质量就很艰难了，这个时候，前面说的，尽量考虑一个大的床是很有必要的这样可以保证即时大家都是右撇子，也能有充足的空间供自己掌握睡眠的方式，而不用会被对方的呼吸等动作惊醒当有了新生儿以后，有可能会在晚上呗小孩吵醒，这个时候，不用在帮助小孩睡觉后立马就开始睡觉，可以在下一个睡眠周期之前，调整一下状态，洗洗衣服，看会电视之类的，然后再下一个睡眠周期来的时候入睡，并且早上也在规定的时间内起床在白天的两个补充睡眠时间段可以小睡半小时或者一个睡眠周期]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏改变世界的读书笔记]]></title>
    <url>%2F2020%2F08%2F14%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B8%B8%E6%88%8F%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[游戏可以提升人民的幸福感游戏最重要的四大要素 目标，每个游戏都会给玩家设定一个目标，这个目标是确定可以达到的，很明确的目标 规则，游戏中各种各样的规则保证了玩家在做任务的有序性，公平，不会像工作中一样产生迷惑 反馈系统，游戏中每个任务都会有明确的奖励机制，并且能清晰的看到离目标还有多远，完成后会有多大的提升 自愿参加，每个玩家都可以自由决定玩还是不玩，这与工作完全不一样，将决定权交与玩家的手中 思考 游戏中的任务不见得会比工作更难，为什么都喜欢玩游戏而不是工作呢？ 把工作看成游戏，是否能大幅度提高工作的效率？ 游戏中的奖励机制 大型游戏中的任务都有很明确的目标，奖励机制也很完善，对于平时的工作而言，大部分的时间并不能轻而易举的看到成果，这样其实对于自身来说就是一个缺陷最近一直没有任务下来，导致其情绪不高也是这个原因，一旦有任务下来，说明就会有清晰的成果出现，也就是说，其实不管是工作还是游戏，只要是能充分发挥自身能力时，那就是最好的状态 失败也可以引导更大的热情 在游戏中，任务的失败是一个常态，但为什么还会一直玩下去，直到成功呢？游戏中的失败给了我们一个积极的反馈，失败是更稳定的，显而易见的，我们能清楚的认识到与目标还差多远现实生活的失败往往却更加的复杂，难以预料 玩游戏所产生的宏观责任感 现实中的社交联系有时候还比不上游戏中的，合作带来的快感也很清晰游戏中定义的宏伟目标会带给人及其强大的作用力，促使人一直朝着这个目标努力 游戏中的平行实景带来的影响 对于现实来说，缺少了反馈机制，也没有奖励的互动，很难让人打起精神来，反而在游戏中，清晰的目标，清晰的奖励反馈都能带给人一种新鲜感，激起人的动力例如，一款家务游戏，通过做家务给虚拟人物升级，任务还可以自己设定，这就很好，带来的反馈里也很长久 将游戏中的回馈机制带入到现实 如果现实中也能有游戏中的回馈机制，那么必然会提高完成工作的效率，减少做某样事情的焦虑这里需要有更多的数据来支撑，例如你写一份ppt，如果旁边不停有+1的鼓励字样展示，那肯定效率和热情能提升一大截回馈机制是一个能极大提升工作效率的方式，通过奖励的刺激，及时得到反馈，对后续的工作会有极大的帮助 游戏中的社群概念 在现实生活中，很少会有人主动接触陌生人，但在游戏里面却完全不会尴尬，因为你知道，游戏中的人对于你来说都是有着相同的目标，这样沟通起来更加方便，亲切一些社会性的问题，比如老年人的孤独问题，都可以在游戏中得到改善，也只有游戏能带给陌生人一些安全感，可以不像现实生活中的感到孤独 持续的参与 最伟大的众人协作任务，维基百科，就是一个最典型的例子，数以千万的人贡献了自己的力量，并且是无偿的，有的只是让人感觉到自豪的情绪英国的一个多人协助检测议员违规报账的事件，同样是一个类似的游戏，只要能带动起更多的人积极性，那么现实社会的工作会变得轻而易举，并且成本会大批量降低 将游戏中的成就拓宽到现实 有的时候在游戏中花费来很大的精力通关，也许对于游戏高手只是一两分钟的事情，但对于自己来说，这就是荣誉，突破了自己，带来了强大的满足感有些游戏借用了这一优点，在现实社会中，也许很少有人会主动帮助别人，但在游戏中，完成一项任务，很多人都会抢着做，把这一部分机制结合到现实中，完全改变了之前遇到的无人区配合的局面 游戏可以培养人的协作能力 所有的游戏都要求合作，好的游戏可以加深人们的合作，协调能力以及预测后续的变化，并针对这些变化作出适当的改变这一点其实和现实中的工作，生活都一样，这些能力能陪伴人的一生，并为之收益 游戏锻炼人的高瞻远瞩 有些社会类游戏可以帮助人们更清楚，更直观的了解世界，并为之努力使之变得更好当今社会下，人的浮躁，焦虑，世界的各种形式变化，都会对人类的未来造成不同的影响，而游戏可以帮助我们改变这个世界，通过一些游戏里的情节，问题，促使我们想到解决现实社会问题的办法，让人更懂得为未来考虑，不能只活在当下]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[el-table的重新渲染]]></title>
    <url>%2F2020%2F07%2F17%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fel-table%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[针对el-table数据的变化，重新渲染dom 由于需要对一个弹出框作一个效果，当下拉框选择指定的值时，就展示table，并显示一个按钮，触发按钮的时候，对table加一行input框，供用户使用数据在写的过程中，发现一个问题，当点击往绑定的table data传入数据的时候，并不生效，必须重新切换下拉框才能完成table的渲染，但通过vuetool发现数据已经更新了，因此，这里使用$set的方法来完成这个赋值操作 预期的效果 代码1234567891011addNewColumn () &#123; console.log(this.formFields.host_address_list) // this.refreshTable() let param = &#123;'host_address': ''&#125; if (isEmpty(this.formFields.host_address_list)) &#123; this.$set(this.formFields, 'host_address_list', []) this.formFields.host_address_list.push(param) &#125; else &#123; this.formFields.host_address_list.push(param) &#125;&#125;,]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask-cors的origin参数设置]]></title>
    <url>%2F2020%2F07%2F17%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fflask-cors%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[flask-cors的跨域设置 近期公司要求，对所有的平台都必须加入跨域限制，不能使用*来表示access-control-allow-origin的值由于不想设定一个白名单，并且如果使用配置文件的白名单方式，每次增加一个域名，就需要重新发布一次平台，太麻烦了，因此决定使用正则的方式来匹配 在使用该模块的过程中，发现利用origin=*.example.com并不能匹配，会直接报错，通过看了这部分源码后了解到，flask-cors模块，对origin支持正则表达式，具体使用了re.match方法来解析的，因此这个参数后面，需要接一个完整的正则表达式 12345678910111213def create_app(config_name, zone): """ 初始化flask app :param config_name: :return: """ app = Flask(__name__,instance_relative_config=True) if zone == 'milk': app.config.from_object(config_milk[config_name]) else: app.config.from_object(config[config_name]) CORS(app, origins="http[s]?://.*.example.com[.hk]*[:]?[\d]*") db.init_app(app)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用github action自动部署博客]]></title>
    <url>%2F2020%2F07%2F07%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%88%A9%E7%94%A8github%20action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[利用github action自动部署博客 原理就是通过上传新文件后，触发该action，然后在服务器上下载该仓库代码，编译，将后续的文件直接push到hexo的静态文件库中即可 创建可以下载代码的密钥 如果github上已经保存有密钥，可以直接使用，如果没有密钥，那么需要生成一对 ssh-keygen -t rsa -b 4096 -f github-actions-deploy会在当前目录下，生成两个文件，github-actions-deploy和github-actions-deploy.pub，一个公钥，一个私钥 将公钥保存到github账户下，自己账户-&gt;settings-&gt;SSH and GPG keys-&gt;生成新的ssh key，将.pub文件内容粘贴到里面，这就是公钥 创建git库 这里需要创建两个git库，一个用来保存博客的源码库，一个是编译后的静态文件的代码库，用来挂靠在github page上展示源码库就是hexo的代码仓库，写的博客文章就保存在里面，设置为私有库 创建github action 在blog的代码库中，点击仓库的settings-&gt;Secrets-&gt;将私钥存入，并设置好钥匙的命名，后续需要使用（例子中保存为HEXO_DEPLOY_KEY) 点击action的tab，然后点击new workflow，将action的文件内容保存 123456789101112131415161718192021222324252627282930313233343536name: HEXO CIon: [push]jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x] steps: - uses: actions/checkout@v1 - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_KEY&#125;&#125; run: | mkdir -p ~/.ssh/ echo "$HEXO_DEPLOY_PRI" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name "xxx" git config --global user.email "xxx.com" - name: Install dependencies run: | npm i -g hexo-cli npm i - name: Deploy hexo run: | hexo g -d 这个文件，可以在本地clone blog仓库的时候，在.github/workflow/中看到]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建alfred workflow并返回结果]]></title>
    <url>%2F2020%2F07%2F05%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%88%9B%E5%BB%BAalfred%20workflow%E5%B1%95%E7%A4%BA%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[alfred workflow的基本创建流程 之前有写过一个利用alfred workflow来上传图片到图床，并返回markdown地址由于之前返回结果就直接存在于剪贴板中，并不需要展示出来供用户来查看，选择，因此不涉及返回结果给alfred并展示的过程因此，这次做了一个workflow的展示版本 base64编码的workflow 由于平时偶尔会使用base64来编码一个字符串或者解码，因此简单创建一个workflow来达到该目的 创建空白workflow，设置关键字触发 具体操作和之前的一样 必填 bundle id是必填的，格式也就是域名反过来，这点和java中的类名有点类似 可以选择一个图片到该workflow里面 创建一个script fliter 这里还是使用python来作为脚本使用bash来传参，调用该脚本 keyword关键字，利用关键字触发 language代表下面的script语法，这里选择input的参数，一般选择下一个 脚本内容就只是一个将用户的输入作为参数，传入执行的脚本中 创建执行脚本 在workflow所在的目录，创建执行脚本执行脚本的名字必须和上面调用的执行脚本文件名字一样例如上面是python *base64encode.py* &quot;{query}&quot;，这里加粗的就是要创建的执行脚本名称 这里是我写的这个workflow的执行脚本内容 12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-import sysimport jsonimport base64args = sys.argvif len(args) &lt;= 1: result = u"No result"else: result = base64.b64decode(args[1])output = &#123;"items": [ &#123; "title": result, "arg": result, "valid": True &#125;]&#125;sys.stdout.write(json.dumps(output, sys.stdout, indent=4)) 注意点 需要注意的地方是，alfred接收的展示结果必须是json或者是xml，上面的output内容就是一个json格式的字符串 关键参数，title是必填的，它代表alfred要展示的结果(下拉菜单里面的具体内容) 还有一个subtitle，可以作为title的补充，如果需要的话，可以在items这个数中加入这个参数，字体会比title小 arg参数，代表了要传给临近的一个filter的结果，由于我这边希望转码了以后，用户回车选择后，传入剪贴板，因此需要这个参数 valid代表了用户敲入回车后返回，虽然文档里面写的这个值默认是True，但是经过测试发现，如果不加这个参数，回车不起作用，只能是command + 具体数字 加入返回结果到剪贴板的动作 可以直接拖动script filter右边缘的节点，像思维导图的下一个节点一样，拖动到空白地方，然后选择一个动作 这里的{query}就代表了，上一个动作传给该动作的参数，也就是arg里面的东西]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask-sqlalchemy模块中mysql连接失效问题记录]]></title>
    <url>%2F2020%2F07%2F05%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fflask%E4%BD%BF%E7%94%A8sqlalchemy%E8%BF%9E%E6%8E%A5%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[flask-sqlalchemy模块中mysql连接失效问题记录 sqlalchemy是python中使用mysql的orm框架flask中使用sqlalchemy的架构图 调用方式 db.engine.execute(sql): 从mysql的连接池获取一个连接，执行完自动commit，归还连接到连接池中 使用orm的session的方式调用 1234db.session.commit()db.session.rollback()db.session.close()db.session.remove(): 底层会调用db.session.close() 线程和session的关系 flask中使用sqlalchemy的时候，每个线程都可以直接用db.session获得session，使用orm的model.query方式，实际上也是调用了session 每个线程有自己的threadlocal的session对象，并且随着线程销毁，会自动释放session,也就是会隐式调用session.remove，释放session的连接 多线程两种使用: t1=threading.Thread(…); 线程池: future= pool.submit(…). 方法1的线程使用完以后自动销毁=&gt;session自动销毁=&gt;连接自动释放; 方法2的线程使用完以后归还线程池=&gt;session手动销毁=&gt;连接释放。 不使用线程池=&gt;连接自动释放; 使用线程池=&gt;连接手动释放. 手动释放的方法: db.session.remove() 空闲连接超时与连接释放bug 前面说到使用线程池时，连接没有自动释放，一直维护在线程的threadlocal存储中(tls)。那么这样似乎也没有什么关系，只要线程池大小&lt;连接池大小,这样连接池有空闲连接，每个线程也有自己的连接可以用，一切似乎也相安无事。然而，这里有一个之前没有提到的机制：空闲连接超时回收。 mysql服务会定时清理掉连接超时的连接，这样客户端保存的该连接的引用都失效了 查看mysql超时时间的命令 12show global variables like &apos;wait_timeout&apos;;set global wait_timeout=10*60; -- seconds flask会定期检查连接池里的连接，删除超时的连接，重新向mysql申请连接，然后放入到连接池中，涉及到的配置参数 app.config[&#39;SQLALCHEMY_POOL_RECYCLE&#39;] 发生bug的可能原因 mysql服务端清除了空闲时间过长的连接; 线程池中线程一直不销毁，因此持有了活了很久的session; 活了很久的session持有了空闲很久的连接, 这个连接其实已经被服务端销毁了，因此已经不可用了，但是由于其一直没有归还到连接池中，因此一直没有得到更新。 此时web服务收到数据请求，使用该线程中的该session中的连接，就会抛异常了，因为连接已经不可用了。 报错提示 12MySQL server has gone awayCan't reconnect until invalid transaction is rolled back]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小强升职记阅读后笔记]]></title>
    <url>%2F2020%2F07%2F01%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[小强升职记 这是一本通俗的介绍时间管理的书，相较于GTD比较浅显易懂 四象限法 大部分的人总是过多沉醉在第一和第三象限中，相当于是被时间追着跑，但其实更重要的第二象限缺乏重视 当第三象限的事情太多，应该考虑是否真的是自己的活，防止猴子事件 提前做好规划，把大部分的精力放在第二象限上 衣物管理法 其实就是平时看书看到的gtd里面的整理-归类-执行的过程 重要点 任务要点判断是项目，任务还是动作，动作就是一个可以马上开始行动的行为，多个动作才会构成一个任务，再往上是项目，像平时我们被分配的写代码其实也算是一个任务，需要具体细分到点 行动的命名 动词开头，决定了立马可以行动 内容清晰，越详细越好，大脑不擅长记忆，有可能今天记住，明后天就忘记了 描述结果，也就是预期达到的目标 设定开始，结束时间，周期，这三个是影响时间安排的关键 行动最佳方案 原则，也就是价值观，自己想过什么样的生活 愿景，职业规划之类的东西，比如，我想要什么，有谁达到了等等 目标，也就是一段时间的规划，比如一年内要做到的事情 责任范围，根据自己在不同环境中扮演的角色要约定自己要做的事情，比如儿子；要善待父母等 任务，包含了任务和项目 下一步行动，最底层的选项，也是行动清单里面的东西，最终落地的部分 番茄工作法 原理在于人的精力是随着时间逐渐降低的，那么我们不能一次性就挥霍完，将任务拆成更小的行动，中间穿插休息可以有效的提高效率，休息时间有助于恢复一部分精力，因为一直让大脑紧绷会产生疲惫 在培养番茄工作的习惯，可以适当加入奖励机制 目标，人都是喜欢玩游戏，因为大脑喜欢做明确的事情，游戏中的任务都是简单明确的，只需要做就可以了 规则，游戏中规则是限制死了，不可能产生别的冲突 及时反馈，完成任务得到的奖励会让大脑产生兴奋，愿意继续下去 自愿参与，把 要我做变成我要做 习惯的培养 培养习惯要遵循小而慢的原则，不要一次性培养多个习惯，而且很急躁，否则后面一旦中断一次，很容易就失败了 习惯养成的重点 自我的驱动力，想一想为什么要养成这个习惯，能带给自己多少的收获，这样才有动力执行下去 奖励机制，每达成多少天能给自己一定的奖励，这样动力也会加深 协同机制，和小伙伴一起行动，更能培养动力 smart法则 想法要落地，可以遵循smart法则来实现 specific，这个想法一定要具体，不能太模糊 measurable，目标是否可以衡量，比如减肥20斤等 attainable，目标的可实现性，也就是说这个目标通过努力一定是会实现的 relevent，完成这个目标对于你的其他目标有帮助 time-based，明确的截止日期 通过思维导图分解这个想法，将一个项目拆成一个个的动作，然后再去除掉不能实现的部分然后去利用甘特图来规划项目排期，每个小里程碑和节点，一旦延期出现，需要重新制定计划 利用九宫图平衡生活 人生不仅仅只有工作，需要在工作和生活之间保持平衡- 心灵 财务 健康 情感 心智 这五项代表了人生的最重要组成部分九宫格里面的内容可以自己根据实际情况填写最中间的格子代表了个人的价值观，使命和愿景，随着人生经历的丰富调整]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个同样的提示框只展示一个]]></title>
    <url>%2F2020%2F07%2F01%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E9%A1%B5%E9%9D%A2%E4%B8%80%E6%AC%A1%E5%A4%9A%E4%B8%AAmessage%E6%8F%90%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[调整message的显示方式 在前台界面上发现，一旦一个页面的cookie过期，这个页面访问了多个请求以后，每个请求校验权限都会被拦截器拦截到，然后在本页面上打出提示，这样一次性就会展示有多个，显示很不友好 通过判断页面dom数中，message的这个元素如果存在一个，那么剩下的就不展示了 123if (document.getElementsByClassName('el-message').length === 0) &#123; Message(&#123;type:'error',message:result.msg&#125;); &#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用alfred workflow实现上传图片到minio]]></title>
    <url>%2F2020%2F06%2F01%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%88%9B%E5%BB%BAalred%20workflow%E6%9D%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0minio%2F</url>
    <content type="text"><![CDATA[利用alfred workflow实现上传图片到minio 代码路径 代码github 搭建minio minio是amazon开源的一个类似s3的存储服务，可以自行搭建到服务器上。minio介绍以及使用文档 搭建很简单，需要注意的是记录下access_key和securet_key，后续脚本调用minio api需要使用到 利用acme.sh脚本自动注册一个ssl证书，这样一个简单的图床就算完成了 创建alfred 利用下图所示，创建一个空白的workflow 设置一个关键字，来调用脚本 设置调用脚本的路径 剩下的就是填充脚本内容即可 脚本大致逻辑 设想的使用方式比较简单，这里简单描述一下，具体可以看代码 首先是利用截图工具截图，然后保存到剪贴板 关键字调用alfred workflow来调用脚本 脚本从剪贴板中获取图片内容，然后写入一个临时文件，将这个文件上传到图床，返回具体的markdown url]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps上搭建图床]]></title>
    <url>%2F2020%2F05%2F27%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%88%A9%E7%94%A8minio%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[使用minio来搭建自己的图床利用docker来部署minio minio是amazon开源的一个类似s3的存储服务，可以用来存储图片，视频等github 地址 安装比较简单 12docker pull minio/miniodocker run -p 9000:9000 minio/minio server /xxx # 目录自定义 配置nginx以及ssl 由于自己买的vps上部署多个服务，域名又只有一个，需要判断用户是通过什么域名访问来将请求转到对应的服务上，这样在dns解析上也比较方便 安装acme脚本 这个脚本是用来定时获取ssl证书的，使用方法也比较简单安装好以后，会发现crontab上有一条记录，这个会自动更新ssl证书 12# 将下载的证书保存到固定的位置，脚本生成的目录位置会有变化，会导致nginx识别不了新的证书acme.sh --installcert -d xx.xxx.com --key-file /xx/xx/xx/key.pem --fullchain-file /xx/xx/xx/cert.pem --reloadcmd "service nginx force-reload" nginx 配置 1234567891011121314server &#123; listen 443 ssl; ssl_certificate /xxx/xxx/xxx/cert.pem; ssl_certificate_key /xxx/xxx/xxx/key.pem; # ssl_dhparam ssl_dhparam /xxx/xxx/xxx/dhparam.pem; server_name xx.xxx.com; location / &#123; proxy_pass http://127.0.0.1:9000; proxy_set_header host xx.xxx.com; &#125;&#125;]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue框架中使用iconfont的图标]]></title>
    <url>%2F2020%2F05%2F27%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fvue%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8iconfont%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[在vue框架中使用iconfont图标 element-ui中的图标太少，需要使用第三方的图标，这里选择了ali的图标库 需要在https://www.iconfont.cn/manage/index?manage_type=myprojects&amp;projectId=1769401上注册帐号 创建项目/或者是加入已有的项目 选择图标加入到具体的项目中（加入购物车后，然后在购物车选择加入项目） 下载到本地(推荐还是通过下载到本地的方式来使用) 将需要的文件放入到项目代码库中，一般是存放于单独的icon目录中 在入口js文件main.js中引入该图标所在的css 然后需要使用什么图标，在iconfont.scss中找到具体的图标类名，然后在其他文件使用就可以了]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastapi学习笔记1]]></title>
    <url>%2F2020%2F05%2F24%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Ffastapi%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[fastapi学习笔记1传入参数 python中使用*来表示，函数定义方法的后面都需要传入变量名，也就是不再是位置参数，而是关键字参数 如果body中只使用了一个json对象，那么可以使用关键字embed来将这个参数转成对象，否则默认就必须是关键字参数的传入办法 123456789101112131415161718192021222324252627282930class Item(BaseModel): name: str description: str = None price: float tax: float = None@app.put("/items/&#123;item_id&#125;")async def update_item(*, item_id: int, item: Item = Body(..., embed=True)): results = &#123;"item_id": item_id, "item": item&#125; return results # 传入的参数格式： &#123; "item": &#123; "name": "Foo", "description": "The pretender", "price": 42.0, "tax": 3.2 &#125;&#125;# 如果没有加`embed`，参数格式就是：&#123; "name": "Foo", "description": "The pretender", "price": 42.0, "tax": 3.2&#125; 传参的定义以及校验 使用pydantic模块以及自身的Query, Body...均可以实现 注意点 传入的参数是datatime类型时，request和response都会转成str，如果返回需要按照你设定的格式，可以使用strftime方法转一次 123456789101112131415161718192021@app.put("/items/&#123;item_id&#125;")async def read_items( item_id: int, start_datetime: datetime = Body(None, format="YY-mm-dd HH:MM:SS"), end_datetime: datetime = Body(None, example="hello,world"), repeat_at: time = Body(None), process_after: timedelta = Body(None),): print(start_datetime.date) print(start_datetime.strftime("%d")) start_process = start_datetime + process_after duration = end_datetime - start_process return &#123; "item_id": item_id, "start_datetime": start_datetime.strftime("%y-%m-%d %H:%M:%S"), "end_datetime": end_datetime.strftime("%y-%m-%d %H:%M:%S"), "repeat_at": repeat_at, "process_after": process_after, "start_process": start_process.strftime("%y-%m-%d %H:%M:%S"), "duration": duration, &#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中旋转动画的效果]]></title>
    <url>%2F2020%2F05%2F15%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fcss3%E4%B8%AD%E5%8A%A8%E7%94%BB%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[css动画旋转 css3新增了transition关键字，作用在于状态变化需要的时间 关键字可以指定具体的属性，比如说height,width等，例如transition: 1s height, 1s width; 关键字可以设定delay的时间，比如有的时候需要某个属性在另外一个属性生效后，等待1秒才开始变化，例如transition: 1s height, 1s 1s width; 状态变化的速度，ease代表不是匀速，逐渐缓慢；liner代表是匀速；ease-in：加速；ease-out：减速；cubic-bezier函数：自定义速度模式 动画animation12345678910111213.deploy-running &#123; animation: rotating 2s linear infinite; color: #67c23a;&#125;@keyframes rotating &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 上面的css代码就是一个旋转的示例，第一个定义了一个css类，定义到要旋转的元素上，下面是实现旋转的方式 需要注意一点的是，如果是对一个icon实现该效果，必须要定义一个块状的结构，单独对于i元素来说不起效果 12345.special-size &#123; font-size: 2.5rem; display: block; /*color: #155724;*/&#125; 文本模糊的问题 问题导致的原因主要是transform关键字导致的问题，一般来说，出现问题的原因在于transform变化的时候如果算出是font-size为小数，浏览器渲染可能就模糊了，像素点的问题，因此需要将字体大小设置得更平滑一些，这一点需要慢慢调试 1-webkit-font-smoothing：antialiased; 上面的代码也可以尝试下 这周遇到的问题，通过在页面上调试，发现是一个父级元素的overflow: hidden导致出来的，因此定义这个visible也就解决掉了 只要掌握了原因，那么调试起来就比较快]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[掌握vue-router的钩子函数以及针对vue ui框架中全局样式的覆盖问题]]></title>
    <url>%2F2020%2F05%2F15%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fvue%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[vue组件钩子函数beforeRouteLeave 有需要针对路由离开的时候关掉定时器，需要用到这个钩子函数 1234beforeRouteUpdate(to,from,next)&#123; console.log('beforeRouteUpdate') next() &#125;, vue中针对全局样式的修改 如果在前端框架中使用了某个ui框架，或者有定义一个全局的css。当有需求需要修改某个组件的样式时，不能使用style scope的方法，应该直接使用style但需要注意的是，需要在设定的css前加上一个父级选择器，否则会修改全局的样式 123456&lt;style&gt;/*需要修改element-ui中的组件样式，但不能影响全局*/ .longHeader .el-card__header &#123; height: 80px!important; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中箭头函数的this作用域]]></title>
    <url>%2F2020%2F05%2F10%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fes%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[js中箭头函数的this作用域 最近有碰到需要在一个方法中，判断完参数后，在执行的时候，再次确认才开始向后台发起请求，因此发起请求的方法中，需要拿到父级代码中的变量，这里不能使用构造函数function () {}，而是应该使用箭头函数来替换 123456789101112131415161718192021startBoot (unit, exec_classification) &#123; try &#123; xxx ... this.$confirm('是否确定执行?', '提示', &#123; confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' &#125;).then(async () =&gt; &#123; this.loadingTable = true let result = await request.post('/apis/deploy_task/startBoot', data) this.getDeployDetail(false) this.$message.success('操作成功！') &#125;).catch((error) =&gt; &#123; console.log(error) &#125;).finally(() =&gt; &#123; this.loadingTable = false &#125;) &#125; catch (e) &#123; console.info(e) &#125; 这里就顺便找了下资料，了解下箭头函数的作用域以及变量(arguments) 箭头函数没有this，他的this是父级作用域中的this，使用了父级的变量，从而形成一个闭包 12345678function foo() &#123; this.a = 1 let b = () =&gt; console.log(this.a) b()&#125;foo() // 1 12345678910function foo() &#123; this.a = 1 let self = this let b = () =&gt; console.log(self.a) b()&#125;foo() // 1 上面两个代码块等价]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy的order_by操作]]></title>
    <url>%2F2020%2F05%2F10%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fsqlalchemy%E7%9A%84order_by%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sqlalchemy的order_by操作 支持后接多个参数以及数组，会依次根据数组的顺序来排序 1User.query.order_by(User.popularity.desc(),User.date_created.desc()).limit(10).all() 后面可以接一个数组，排序是按照数组的顺序来排的，例如上面的例子，就是先按照popularity进行排序操作，然后再进行date_created排序]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用element-ui中碰到的棘手问题]]></title>
    <url>%2F2020%2F04%2F25%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E4%BD%BF%E7%94%A8vuejs%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%985%2F</url>
    <content type="text"><![CDATA[使用el-tree来实现动态覆盖掉原生图标 需要直接覆盖掉原生的样式 12345678910111213141516171819.el-tree .el-tree-node__expand-icon.expanded &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg) !important;&#125;.el-tree .el-icon-caret-right:before &#123; content: "\e78a"; font-size: 18px; color: #606266;&#125;.el-tree .el-tree-node__expand-icon.expanded.el-icon-caret-right:before &#123; content: "\e784"; font-size: 18px; color: #606266;&#125;.el-tree .el-tree-node__expand-icon.is-leaf:before &#123; content: "\e785"; font-size: 18px; color: #606266;&#125; 这里的content可以直接从element-ui的主页面，查看元素，然后查看具体的before字段里的content即是可以直接从css中复用的部分 textarea的一些属性设置 内容不换行，增加横向滚动条 white-space: nowrap 默认的框会检查英语语法，不通过会出现红色的波浪条，这里去除掉 spellcheck=&quot;false&quot; 12&lt;textarea v-model="operRecords" spellcheck="false" style="height: 550px;width: 100%;background-color: black;color:whitesmoke;white-space: nowrap;"&gt;&lt;/textarea&gt; 针对el-tree组件懒加载的方式，重置load所有节点 在el-tree组件中定义ref值，然后通过这个值重新生成最初始的nodes值 123456refresh () &#123; this.fileName = '' this.fileCreated = '' this.operRecords = '' this.$refs.fileTree.root.setData([&#123;name: '/web/logs', 'nodeKey': '/web/logs'&#125;])&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库分页的使用优劣]]></title>
    <url>%2F2020%2F04%2F18%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[针对数据进行paginate，使用offset的优劣 首先要了解，使用offset+limit的原理 offset即是偏移量，首先是通过对id排序，，然后通过在&lt;result offset子句&gt;中指定的行数从起始处丢弃指定的行数来限制 如果offset的值过于大，那么获取到的数据量也会很大，这样会造成性能的消耗 从分页的角度来看，也就是说页数越靠后，那么每次获取到的数据都会越来越多(在抛弃不要的数据之前) 针对以上的情况，使用keyset的方式来进行分页操作是最好的 123456SELECT ... FROM ... WHERE ... AND id &lt; ?last_seen_id ORDER BY id DESC FETCH FIRST 10 ROWS ONLY 这种方式在于可以定量选取部分数据 但由于要存储额外的主键id字段，然后再使用这个字段来获取需要的数据量]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vuejs最近碰到的问题记录]]></title>
    <url>%2F2020%2F04%2F18%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E4%BD%BF%E7%94%A8vuejs%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%984%2F</url>
    <content type="text"><![CDATA[vue在dom重新渲染时有一个性能优化机制，就是相同dom会被复用 针对el-table，使用:key=&quot;math.random()&quot;来绑定一个不重复的值，这样就可以保证在dom改变的时候，不允许复用，从而达到重新渲染的目的 在vue中使用calc来实时计算数值 由于element框架中嵌套了过多的组件，需要根据不同的屏幕大小来实时计算一些属性 有定义该字段的 例如el-table，本身组件中有定义height的定义方法，可以直接使用变量 123data: return &#123; pageHeight: document.body.scrollHeight&#125; 12&lt;el-table :height="this.pageHeight - 420" 没有定义该字段的 一方面可以使用:style={obj}来绑定（我在el-table中尝试了下，来定义table的宽度，但实际情况没有成功，应该是被原生的样式覆盖掉了 定义一个css类，在设置css属性值的时候计算 123.table-style &#123; width: calc(100vw - 300px);&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实地利用monkey patch来增加功能]]></title>
    <url>%2F2020%2F04%2F12%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2F%E4%BD%BF%E7%94%A8monkey%20patch%E6%9D%A5%E5%A2%9E%E5%8A%A0requests%E7%9A%84timeout%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[使用monkey patch的方式增加或修改老系统里的一些方法属性 最近有发现，开发的系统中有一个请求第三方接口的方法并没有设置超时时间，需要统一给增加一个超时时间，但不影响设置了超时时间的方法，因此使用monkey patch的方式，在系统启动的时候，修改使用的requests方法 1234567891011# money patch for requestsdef request_patch(slf, *args, **kwargs): print(f"Fix called, old_timeout=&#123;kwargs.get('timeout')&#125;") timeout = kwargs.get('timeout', 5) print(f"Fix ok, now timeout=&#123;timeout&#125;") return slf.request_orig(*args, **kwargs, timeout=timeout)if __name__ == '__main__': setattr(requests.sessions.Session, 'request_orig', requests.sessions.Session.request) requests.sessions.Session.request = request_patch 这里只针对了使用requests.get/post的使用方式，如果有使用requests.session，需要继承该类，然后修改里面的一些属性 12345678910import requestsclass SessionTimeoutFix(requests.Session): def request(self, *args, **kwargs): print("Fix called") timeout = kwargs.pop('timeout', 2) return super().request(*args, **kwargs, timeout=timeout)requests.sessions.Session = SessionTimeoutFix]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui使用的问题记录3]]></title>
    <url>%2F2020%2F04%2F12%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Felement-ui%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%953%2F</url>
    <content type="text"><![CDATA[修改el-dialog中的高度 审查页面元素中，看到是一个el-dialog__body的css类在控制，因此需要控制的也就是这个 在el-dialog中定义custom-class 然后在css中，定义该元素的展示 12345678910.elmentSellChangeTypeDialog &#123; width: 320px; height: 650px; border-radius: 10px; overflow: auto; .el-dialog__body &#123; padding: 0; &#125;&#125; el-form的验证问题 可以针对某一行的数据进行单独校验 主动校验字段 this.$refs[formName].validate((valid) =&gt; {} 1234&lt;el-form-item label="健康检查URL" prop="health_check_uri" :rules="[&#123;validator: checkHealth, trigger: 'blur'&#125;]" class="normal"&gt; &lt;el-input v-model="deployJobForm.health_check_uri" placeholder="e.g.,/check" clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; 1234567checkHealth (rule, value, callback) &#123; if ((value === '' || value === null) &amp;&amp; this.deployJobForm.health_check_type === 2) &#123; return callback(new Error('请填写健康检查URL')) &#125; else &#123; return callback() &#125;&#125;, 123456789submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; alert('submit!'); &#125; else &#123; console.log('error submit!!'); &#125; &#125;);&#125; el-dialog的弹出框，点旁边区域不自动关闭 在dialog中加入属性值:close-on-click-modal=&quot;false&quot;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs的watch监控对象]]></title>
    <url>%2F2020%2F04%2F12%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fvue%E4%B8%AD%E7%9A%84watch%E6%B7%B1%E5%BA%A6%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[vuejs中watch监控对象的某个元素 使用deep来控制监控器对某个对象的具体一个元素进行监控 12345678910111213141516171819202122&lt;div&gt; &lt;p&gt;obj.a: &#123;&#123;obj.a&#125;&#125;&lt;/p&gt; &lt;p&gt;obj.a: &lt;input type="text" v-model="obj.a"&gt;&lt;/p&gt;&lt;/div&gt;new Vue(&#123; el: '#root', data: &#123; obj: &#123; a: 123 &#125; &#125;, watch: &#123; obj: &#123; handler(newName, oldName) &#123; console.log('obj.a changed'); &#125;, immediate: true, deep: true &#125; &#125; &#125;) immediate:true代表如果在 wacth 里声明了 firstName 之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行 watch 里面的属性 deep，默认值是 false，代表是否深度监听 监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler 优化的方式就是使用字符串的方式来监听 这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数 123456789watch: &#123; 'obj.a': &#123; handler(newName, oldName) &#123; console.log('obj.a changed'); &#125;, immediate: true, // deep: true &#125;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui最近使用上的问题记录]]></title>
    <url>%2F2020%2F04%2F05%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Felement-ui%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[element-ui最近使用上的问题记录el-link新窗口弹出 el-link实质上也是一个&lt;a&gt;，因此直接使用target=&#39;_blank&#39;就可以在新窗口打开 加入一个icon，可以通过设置font-size来设置icon的大小 el-input修改里面的placeholder颜色123456789/deep/ input::-webkit-input-placeholder &#123; color: #c0c4cc;&#125;/deep/ input::-moz-input-placeholder &#123; color: #c0c4cc;&#125;/deep/ input::-ms-input-placeholder &#123; color: #c0c4cc;&#125; deep的意思在于可以通过设置父组件来影响子组件中的样式]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor]]></title>
    <url>%2F2020%2F03%2F30%2Fsupervisor%2F</url>
    <content type="text"><![CDATA[安装supervisor pip install supervisor 注意报错：pkg_resources.DistributionNotFound: meld3&gt;=0.6.5,需要升级setuptools pip install -U setuptools echo_supervisord_conf &gt;/etc/supervisord.conf 生成配置文件 mkdir /etc/supervisord.d/ 生成配置目录 在supervisord.conf文件中，加入以下内容 123&lt;!--more--&gt;[include]files = /etc/supervisord.d/*.conf]]></content>
      <tags>
        <tag>supervisor</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue父子组件以及el-table的行高设置]]></title>
    <url>%2F2020%2F03%2F28%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Felement-ui%E4%B8%AD%E5%AF%B9table%E7%9A%84%E8%A1%8C%E9%AB%98%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[element-ui针对table设置行高 默认的行高比较高，有时候在弹出框中使用table的方式，会导致一些展示问题，或者数据比较多，浪费太多的空间 12345678&lt;el-table :data="tableData" style="width: 100%" row-style="height:0" cell-style="padding:0" max-height="90%" &gt; vue中父组件直接调用子组件的方法 给子组件定义一个ref值，&lt;child-component ref=&quot;childTask&quot;&gt;&lt;/child-component&gt; 父组件中使用，直接通过this.$refs.child.xxxx使用即可]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单说下最近使用flask钩子函数遇到的问题]]></title>
    <url>%2F2020%2F03%2F28%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fflask%E4%B8%AD%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[flask中的钩子函数before_request, after_request钩子函数 关于这两个函数，一直贯穿请求的整个流程 before_request是在请求进来时，还没有进入主体接口函数，一般可以用来做一些鉴权的操作 after_request是接口函数返回后(包括了返回的response，因此这个钩子函数必须要返回一个结果给wsgi)，可以针对请求的回应加入一些额外的结果 最近有碰到一个问题，由于鉴权是另外一个装饰器，使用在了具体的接口上，对于接口的返回，必须要判断是否有管理员权限才给返回正确的，否则需要返回一个401错误(前端已经定义401跳转操作) 123456789@app.after_requestdef after_request_callback(res): if request.method != 'OPTIONS': if g.user.is_ops: return res else: return Response('', 401) else: return res teardown_request 在after_request后才开始调用主要对于请求完成后的一些关闭资源的操作，例如关闭db.session的操作都可以放在这里面 12345678@app.teardown_requestdef teardown_request(exception=None): try: db.session.remove() except: passreturn app flask中的response对象 有的时候需要在接口返回的response对象中获取到具体的信息，需要使用get_data方法来获取如果需要针对当前的response对象加入一些信息，可以使用set_data方法set_cookie(key, value)定义cookie中的一些内容]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的封装]]></title>
    <url>%2F2020%2F03%2F22%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Faxios%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[axios的封装 axios是一个基于promise的http库，主要用来对api的请求接口，返回结果进行封装 常用设置 axios.defaults.timeout = 10000; 默认请求超时时间，如果超过，会通知用户重新刷新页面 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;; 请求头的设置 请求拦截 有的时候，页面需要用户登录才能访问，或者是需要序列化我们的post数据 123456789101112131415161718192021222324252627282930313233service.interceptors.request.use( config =&gt; &#123; //定义取消请求函数 let cancel = undefined; config.cancelToken = new axios.CancelToken(function executor(c) &#123; cancel = c; &#125;); //放置重复请求 let nowTime = new Date().getTime(); requestList = requestList.filter((item) =&gt; &#123; return (item.setTime + saveTime) &gt; nowTime; &#125;); let sessionUrl = requestList.filter((item) =&gt; &#123; return item.url === config.url; &#125;); if (sessionUrl.length &gt; 0) &#123; console.info(config.url + '请求重复 中断请求!'); cancel(config.url) return; &#125; // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 let login_token = Cookies.get("login_token"); if (login_token) &#123; config.headers.Authorization = login_token; return config; &#125; return config; &#125;, error =&gt; &#123; // Do something with request error return Promise.reject(error); &#125;); 响应的拦截 比如，后台返回给前台的错误码是404，5xx之类的错误时，我们并不想让用户知道这些错误信息，因此让用户看到另外一个页面，优化体验 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465service.interceptors.response.use( response =&gt; &#123; store.commit('setNetworkState',true); let result=response.data; if(result.state)&#123; return Promise.resolve(result.data); &#125;else&#123; Message(&#123;type:'error',message:result.msg&#125;); if(result.code === 401)&#123; setTimeout(() =&gt; &#123; Cookies.set("return_url",process.env.FRONT_ROOT + '/#' + router.currentRoute.fullPath,&#123; domain: process.env.COOKIE_DOMAIN &#125;); window.location.href = process.env.LOGIN_ROOT; &#125;, 1000); &#125;else if(result.code === 403)&#123; setTimeout(() =&gt; &#123; router.push('/403'); &#125;, 1000); &#125; return Promise.reject(result.msg); &#125; &#125;, error =&gt; &#123; console.info(error) if(error.response)&#123; store.commit('setNetworkState',true); let status=error.response.status; let result=error.response.data; console.info(error.response); switch(status)&#123; case 400: Message(&#123;type:'error',message:result.msg&#125;); break; case 401: Message(&#123;type:'error',message:result.msg&#125;); setTimeout(() =&gt; &#123; Cookies.set("return_url",process.env.FRONT_ROOT + '/#' + router.currentRoute.fullPath,&#123; domain: process.env.COOKIE_DOMAIN &#125;); window.location.href = process.env.LOGIN_ROOT; &#125;, 1000); break; case 403: setTimeout(() =&gt; &#123; router.push('/403'); &#125;, 1000); break; case 404: setTimeout(() =&gt; &#123; router.push('/404'); &#125;, 1000); break; case 405: Message(&#123;type:'error',message:"服务器内部错误，请与管理员联系或稍后重试"&#125;); break; case 500: Message(&#123;type:'error',message:"服务器内部错误，请与管理员联系或稍后重试"&#125;); break; default: Message(&#123;type:'error',message:"服务器未知错误，请与管理员联系或稍后重试"&#125;); &#125; return Promise.reject(error.response); &#125; else&#123; /// 断网了 store.commit('setNetworkState',false); &#125; &#125;); 封装具体的方法 get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数 post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的 注意 axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。 api的管理 为了方便管理各个页面上的接口，降低代码的耦合度，也可以增加接口的复用，可以将所有的请求接口放到模块中管理进去 可以新建一个文件夹，每个模块一个req.js文件，放入具体涉及到的接口内容 index.js api的出口，主要用来export给页面使用 12345678910 // 资源接口import article from '@/api/v1/resource';// 其他模块的接口……// 导出接口export default &#123; resource, // ……&#125; base.js 管理接口域名 1234567// 可以定义多个域名const base = &#123; sq: 'https://xxxx111111.com/api/v1', bd: 'http://xxxxx22222.com/api'&#125;export default base; 使用的时候，直接引入具体的方法就可以了，和组件的引用类似 123456import base from './base'; // 导入接口域名列表import axios from '@/utils/http'; // 导入http中创建的axios实例/**具体方法接口实现**/export default article; //导出具体方法名 - 最后，为了方便，将整个挂载到vue实例(this)上去，通过new Vue对象来实现 - 也可以挂载到vue原型上，但是vuex就无法访问了]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vuejs过程中遇到的问题(三)]]></title>
    <url>%2F2020%2F03%2F15%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E4%BD%BF%E7%94%A8vuejs%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%983%2F</url>
    <content type="text"><![CDATA[使用vuejs过程中遇到的问题(三) 大部分都是配合element-ui来搭建前端框架 el-table高度设置，单元格内容居中 为了达到页面中table的最大高度，出现y轴上的滚动条，可以设置max-height el-table-column 设置为aligh:center，内容显示居中 element ui框架中table的分页问题 在分页的清空下，如果切换了页码，那么之前页里面的选择框就默认消失了，这里可以使用框架提供的方法来解决这个问题也可以处理，在用v-for来渲染同个table的时候，如何保持住不同table的选择框状态 在el-table中加入:row-key=&quot;getRowKeys&quot; 加入methods 123getRowKeys (row) &#123; return row.id &#125;, 在选项框那一列，加入:reserve-selection=&quot;true&quot; 加入清除机制， this.$refs.tableName.clearSelection()就可以清除掉 vue中的v-for循环出来的多个ref对象，如果捕获 可以使用this.$refs.xxxx来展示名字为xxxx的元素，返回的是一个数组 123this.$refs.newDataTable.forEach(row =&gt; &#123; row.clearSelection() &#125;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy使用过程中的问题]]></title>
    <url>%2F2020%2F03%2F15%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fsqlalchemy%E4%BD%BF%E7%94%A8%E5%88%A0%E9%99%A4%E5%92%8Cin%E5%85%B3%E9%94%AE%E5%AD%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[sqlalchemy使用过程中的问题 使用in_关键字的时候，如果后面有跟update和delete，需要增加参数来执行。因为该orm需要评估你这个语句的风险以及后续的返回 12db.session.query(HostList).filter(HostList.ip.in_(deal_hosts_list)).\ update(&#123;HostList.used_status: 0&#125;, synchronize_session=&apos;fetch&apos;) synchronize_session的参数说明 False 不同步 session，如果被删除的 objects 已经在 session 中存在，在 session commit 或者 expire_all 之前，这些被删除的对象都存在 session 中。 不同步可能会导致获取被删除 objects 时出错。 fetch 删除之前从 db 中匹配被删除的对象并保存在 session 中，然后再从 session 中删除，这样做是为了让 session 的对象管理 identity_map 得知被删除的对象究竟是哪些以便更新引用关系。 evaluate 默认值。根据当前的 query criteria 扫描 session 中的 objects，如果不能正确执行则抛出错误，这句话也可以理解为，如果 session 中原本就没有这些被删除的 objects，扫描当然不会发生匹配，相当于匹配未正确执行。 注意这里报错只会在特定 query criteria 时报错，比如 in 操作]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[localStorage和sessionStorage的区别]]></title>
    <url>%2F2020%2F03%2F15%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E5%89%8D%E7%AB%AFlocal%E5%92%8Csession%E4%B8%A4%E4%B8%AAstorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[localStorage和sessionStorage的区别 两者都可以拿来作为缓存 区别 localStorage生命周期是永久，浏览器不清除就代表一直存在 不同浏览器无法共享localStorage，同一个浏览器不同页面可以共享（页面属于相同域名和端口 sessionStorage的特点 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了 sessionStorage的大小最大只有4kb 不同页面或标签页间无法共享sessionStorage的信息 通过getItem或直接使用localStorage[“key”]获取到的信息均为实际存储的副本，不能直接通过修改对象达到修改值的目的 使用 setItem localStorage.setItem(this.$route.params.deploy_job_id + &#39;-&#39; + unitId, JSON.stringify(this.selectedHosts)) getItem JSON.parse(localStorage.getItem(this.$route.params.deploy_job_id + &#39;-&#39; + unit)) 这里需要注意的是，存储和读取的逻辑和redis操作有点类似，都必须是string类型，如果存储的是obj或者arr，都需要利用json模块转一次；读取的时候，再解析成obj即可]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vuejs过程中遇到的问题(二)]]></title>
    <url>%2F2020%2F03%2F09%2F5%E5%89%8D%E7%AB%AF%2Fvue%2F%E4%BD%BF%E7%94%A8vuejs%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%982%2F</url>
    <content type="text"><![CDATA[使用vuejs过程中遇到的问题(二)定时器 定时器的目的在于固定时间，或者周期内不断执行某个业务。主要分为setTimeout(定时执行)和setInterval(循环执行) setInterval(func, delay_time-毫秒) setTimeout(func, delay_time-毫秒) 第一个参数方法名不需要括号，可以理解为把方法当作参数传给了定时器，和python的装饰起写法有点类似 箭头函数和普通函数的区别常规函数12345678910 function test(name) &#123; //声明式写法 console.log(name) &#125; test('Jerry')// 第二种 let test2 = function(name) &#123; //赋值式写法 console.log(name) &#125; test2('Tom') 它的调用方式也是func.call(this, params)等价于(func(params)) call的调用方式默认的第一个参数就是this，也就是windows对象 1234567891011121314151617const obj = &#123; name: 'Jerry', greet: function() &#123; console.log(this.name) &#125;&#125;obj.greet() //第一种调用方法obj.greet.call(obj) //第二种调用方法// 手动指定thisconst obj = &#123; name: 'Jerry', greet: function() &#123; console.log(this.name) &#125;&#125;obj.greet.call(&#123;name: 'Spike'&#125;) //打出来的是 Spike 箭头函数 只有赋值的定义方法 如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号 如果函数体只有一句话，可以不加花括号 如果函数体没有括号，可以不写return，箭头函数会帮你return 123456789101112const test = name =&gt; &#123; console.log(name)&#125;test(&apos;Jerry&apos;)const test2 = (name1, name2) =&gt; &#123; console.log(name1 + &apos; and &apos; + name2)&#125;test2(&apos;Tom&apos;, &apos;Jerry&apos;)const add = (p1, p2) =&gt; p1 + p2add(10, 25) 构造函数里的this稍微有点特殊，每个构造函数在new之后都会返回一个对象，这个对象就是this，也就是context上下文 window.setTimeout()和window.setInterval()的函数中的this有些特殊，里面的this默认是window对象。 对于箭头函数来说有两个不一样的地方 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。 不能用call方法修改里面的this 1234567891011121314151617181920212223const obj = &#123; a: () =&gt; &#123; console.log(this) &#125;&#125;obj.a() //打出来的是windowconst obj = &#123; a: () =&gt; &#123; console.log(this) &#125;&#125;obj.a.call(&apos;123&apos;) //打出来的结果依然是window对象// 多层嵌套const obj = &#123; a: function() &#123; console.log(this) &#125;, b: &#123; c: () =&gt; &#123;console.log(this)&#125; &#125;&#125;obj.a() //没有使用箭头函数打出的是objobj.b.c() //打出的是window对象！！]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs常见问题]]></title>
    <url>%2F2020%2F02%2F29%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fvuejs%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[近期针对element-ui的使用过程中的问题针对table组件中的选择框事件(selection-change) 由于近期碰到需求，需要在页面中渲染一个列表中的多个数据，各个数据都需要使用table组件来渲染，因此这里使用v-for+table组件来渲染。需要将table中用户选中的行，传入该循环体的某个值，因此需要额外针对selection-change事件传入多的参数默认的selection-change事件传入的是选中行的数据对象，可以使用$event来代替，后面就可以接额外的参数 12345678910111213&lt;el-table tooltip-effect="dark" class="table-style" ref="singleTable" highlight-current-row border stripe @selection-change="unitCheckChange($event, unit.unit_id)" :data="unit.host_list"&gt; &lt;el-table-column type="selection" width="auto"&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 针对v-for循环渲染某个select组件，组件绑定值 针对循环使用了多个select的组件情况，可以赋值一个对象或者数组来绑定具体的值 12345678&lt;el-select v-model="formInline[unit.unit_id]" placeholder="请选择分组"&gt;&lt;el-option v-for="item in deployModeList" :key="item.id" :label="item.desc" :value="item.id"&gt;&lt;/el-option&gt;&lt;/el-select&gt; 父组件和子组件的相互传递数据 当父组件需要向子组件传递一些参数的时候，可以将要传入的参数放入子组件的props列表中当子组件需要调用父组件的自定义方法，可以使用$emit来使用 在子组件中定义 123456789&lt;!-- 定义需要使用的参数 --&gt;export default &#123; name: 'deploy-record', props: ['dialogFormVisible', 'execRecords', 'req_url'], data: function () &#123; return &#123;&#125;&#125; methods: &#123; close () &#123; this.$emit('close') &#125; 在父组件中使用子组件 1234567&lt;!-- 弹出详情 --&gt;&lt;deploy-record :dialogFormVisible.sync="dialogFormVisible" :task_id="select_unit_id" :req_url="reg_url" :execRecords="execRecords" @close="close"&gt;&lt;/deploy-record&gt; el-table中的选择框默认禁止 使用:selectable=&#39;checkboxInit&#39;，定义一个方法返回0，1来实现 123456checkboxInit(row, index)&#123; if (xxx) return 0;//不可勾选 else return 1;//可勾选 &#125;, pre 中高度，宽度的滚动条 style=&quot;overflow:auto;max-height: 200px&quot;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google 写技术文档的标准]]></title>
    <url>%2F2020%2F02%2F29%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E6%80%8E%E4%B9%88%E5%86%99%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[google 写技术文档的标准定义一个全新或者不熟悉的专业词汇 如果这个词汇已经被人定义过，可以给文档中加入一个完整描述的链接 如果文档中对专业词汇定义很多，需要给出一个完整的词汇列表 一致性 在文档中，对一个专业词汇要保持一致的写法 错误的示范Protocol Buffers provide their own definition language. Blah, blah, blah. And that&#39;s why protobufs have won so many county fairs. 正确的示范Protocol Buffers (or protobufs for short) provide their own definition language. Blah, blah, blah. And that&#39;s why protobufs have won so many county fairs. 缩写词的使用 TTN = Telekinetic Tactile Network 如果缩写词不是特别长，例如MapReduce没必要使用MR来定义 在文档中使用缩写词，需要在第一次使用的时候，使用完整，并用括号来包裹缩写词 This document is for engineers who are new to the Telekinetic Tactile Network (TTN) or need to understand how to order TTN replacement parts through finger motions. 代词的使用 主要在于上一个语句中的短语太多，代词不能清晰得指向具体是哪一个 You may use either Frambus or Foo to calculate derivatives. This is not optimal. 使用主动语态代替被动语态 Active Voice Sentence = actor + verb + targetPassive Voice Sentence = target + verb + actor主动语态更能让人明确actor的主导 主动语态：The cat sat on the mat. 被动语态：The mat was sat on by the cat. 使用强动词来加深理解，避免弱动词的使用 强动词例子： The error occurs when clicking the Submit button. 弱动词例子： Clicking the Submit button triggers the error. 这个和上面讲的被动语态有一点重叠，主要在于需要加深读者的印象 尽量少使用there is/there are There is a variable called met_trick that stores the current accuracy. 替换为A variable named met_trick stores the current accuracy. The met_trick variable stores the current accuracy.明显更加清晰 减少一些形容词和副词的使用 Setting this flag makes the application run screamingly fast. 替换为Setting this flag makes the application run 225-250% faster.更加清晰明确 使用短小的句子来表达 和维护代码类似，短句能带来更多的优势 更加清晰，方便阅读 方便维护(修改) 文档中额外的部分导致的歧义也会更多 和写代码类似，使用break和continue来减少长语句，比如使用1,2,3或者直接是小圆点，分段表达 减少子语句，一个语句只表达一个观点就行，I prefer to code in C++ because I like strong data typing.可以切成两个 减少引起子语句的词(which, that），这里有个小提示，对于美国人来讲，使用which标识前后两个语句需要一点暂停，而使用that则不需要 使用列表和表格列表 无序列表，每一行都可以抽出来，并不影响剩下的行表达的意思 有序列表，代表是有一定紧密联系的，抽出任意一行，都会影响到其他行的意思 嵌入式列表(也就是一行语句中包含了多个独立单词的意思)，这里并不提倡使用这种方式来写技术文档 The llamacatcher API enables callers to create and query llamas, analyze alpacas, delete vicugnas, and track dromedaries. 对于列表来说，列表中的每一个元素都应该是格式完全一致的例如都是一个完整的句子（首字母要大写都大写，都使用同一个语态)，都是一个单词等 表格 和列表类似，表格也需要突出每一列的数据都应该是同一个格式和类别 不要在一个单元格中放入太多的字段 段落 每一个段落中都应该有明确的中心思想 每一个段落都应该表达一个明确的主题，不要在一个段落中引入其他段落的意思，容易给读者造成混淆 不要使用一句话的段落，使用短句来表达。 一个好的段落应该包含以下方面： 这个段落具体要讲什么 对于读者的重要性在什么地方 读者怎么认同这个观点 面向的受众 技术文章里的一些词汇都比较专业，如果给一个不是很熟悉的人来阅读，那么会造成读者很大的困扰。因此，你的技术文章如果技术性比较强，那么你需要列举出能读懂你这篇文章的前提条件是什么 决定你的受众（技术人员，设计人员,) 你的受众需要掌握的知识(java, python, c,) 使用简单的词汇来表达准确的含义，不要使用成语，俚语等只有一部分人知道意思的词汇 文档 明确指出文档内容涉及到的范围 指定所限的受众体 文档要在前面就明确指出你这篇文档的关键点 把你的话题拆成几部分，每一部分能让读者了解到一个具体的事物(完成一项具体的小任务这种) google writing style]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask-apschedule中没有app上下文的解决方案]]></title>
    <url>%2F2020%2F02%2F17%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fflask_apschedule%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[flask-apschedule中遇到的问题无法使用flask-sqlalchemy的问题 报错在于： RuntimeError: No application found. Either work inside a view function or push an application context 操作db需要app，而定时器在后台运行实际上是找不到app的，需要push一个app context给它，让它在上下文里面工作 解决方案： 可以再次创建一个app 12345678910111213141516171819202122232425import osfrom datetime import datetime, timedeltafrom dop_comm import db, loggerfrom dop_comm.models.deploy import RegistryCenterfrom dop_comm import create_appfrom register_center.config import config_envdef chk_app_status(): # 获取环境变量 env = os.getenv('FLASK_ENV', 'default') # 创建app app = create_app(config_env[env]) chk_time = (datetime.now() - timedelta(minutes=5)) try: with app.app_context(): db.session.query(RegistryCenter). \ filter(RegistryCenter.heartbeat_time &lt; chk_time, RegistryCenter.status == 0). \ update(&#123;RegistryCenter.status: 1&#125;) db.session.commit() except Exception as ex: logger.error(f"Check all app status failed, error=&#123;ex&#125;") db.session.rollback() 有一个问题就是如果任务较多，或者间隔很短，那么就会生成很多的app实例，会导致数据库session连接数过大，文件调用过多等 使用一个固定的模式来创建app 123456789101112from app import create_appAPP = Nonedef get_app(): global APP APP = APP if APP is not None else create_app(args) def shcduler_job1(): get_app() with APP.app_context: do the job]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖延症的产生]]></title>
    <url>%2F2019%2F04%2F11%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%8B%96%E5%BB%B6%E7%97%87%2F</url>
    <content type="text"><![CDATA[ted拖延症视频拖延的产生 感觉说的还是有道理，尤其是当一件事情没有截止日期的时候，总会故意遗忘掉。人都是想过安逸和简单的事情，脑子里面虽然会时而想起，但过一会又会遗忘掉 解决办法 总是主动设置一个截止日期，这需要对任务进行拆分，将较大的任务拆分成小任务，争取每天能完成一个 复盘，定时去查看自己任务还有多少，及时调整，针对拖延的事情有一个大致的概括，也算作一个教训 把一件事情养成了习惯以后，那么到了这个时间点以后，身体记忆会产生行动的动力来做 给自己设定一个欲望清单，里面的东西都需要按时完成才能达到消费的目标，如果没有完成也需要相应的扣除掉]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中的索引数据结构]]></title>
    <url>%2F2019%2F03%2F27%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fmysql%E4%BD%BF%E7%94%A8B%2B%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[mysql的索引使用B+树的原因 大致有以下两方面的原因，一个是单位时间内获取到的结果，二是每个节点读取的时间成本 对于查找来说，一般二分查找(例如平衡二叉树)能极大提高查找的效率 存储层次 计算机的存储从上到下大致可以分为寄存器、高速缓存、主存储器、辅助存储器。其中主存储器，也就是我们常说的内存；辅助存储器也被称为外存，比较常见的就是磁盘、SSD，可以用来保存文件。在这个存储结构中，每一级存储的速度都比上一级慢很多，所以程序访问越上层存储中的数据，速度就会越快 相较与二叉树，B+树每次查询节点能得到更多的数据，因此在B+树中，查询所需的节点比二叉树要少得多 节点读取的时间消耗 对于操作系统来说，把磁盘读取到内存中的单位页,每次读取都需要完整的读取一页的数据，一般来说4kb 如果一个节点的大小小于一页的大小，那么就会有一部分时间花在读取我们根本不需要的数据上（节点之外的数据），二叉树在这方面就会浪费很多时间；而如果一个节点的大小大于一页，哪怕是一页的整数倍，那我们也可能在一个节点的中间就找到了我们需要的指针进入了下一级的节点，这样这个指针后面的数据都白白读取了，如果不需要这些数据可能我们就可以少读几页了。 对于索引来说，能使用一个节点大小刚好就是该操作系统一页的大小的数据结构就是效率最高的 B+树可以满足上述条件]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读博客的笔记]]></title>
    <url>%2F2019%2F03%2F19%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E4%B8%AA%E4%BA%BA%E6%95%88%E7%8E%87%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一位成功人士的效率提升提示原文阅读 不用事无巨细的记录下所有的事情；更加专注于自己最重要，最关心的事情 给自己划分3个关注列表，一个是马上或者正在做的，一个将来规划要做的，一个所有想做的，随时都能做的都放在里面 睡觉之前，记录下明天必须要做的事情 有计划的拖延策略；这里作者的意思是，当自己状态不好，或者说事情不是特别紧急(截止日很长)，可以有计划的做其他的事情来替换该事情 每天定时查看邮件，不用一来邮件就立刻去关注，有规律的一次性清空邮箱 拒绝不停的电话干扰 和上一条类似，为了避免分心，可以给自己手机设置飞行模式(这里作者介绍的是ipod，不能打电话，只能听歌) 信守承诺，答应做的事情一定要按时完成；反之，做不到的事情就不要答应 做你自己喜欢做的事情]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7上的firewall介绍]]></title>
    <url>%2F2019%2F01%2F24%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fcentos7%E4%B8%8A%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[centos7 防火墙设置 centos7默认安装的防火墙是firewall，替换掉了centos6上的iptables，这里简单介绍下该命令 安装 yum install -y firewalld 启动/停止 启动 systemctl start firewalld 停止 systemctl stop firewalld 重启 systemctl restart firewalld 查看状态 systemctl status firewalld 服务/端口的添加，去除 添加服务，其实就是开启22端口 firewall-cmd --permanent --add-service=ssh 添加端口 firewall-cmd --permanent --add-port=1234/tcp 删除服务 firewall-cmd --permanent --remove-service=ssh 删除端口 firewall-cmd --permanent --remove-port=1234/tcp 查看被firewalld允许的服务 firewall-cmd --permanent --list-all 使操作生效firewall-cmd --reload 开机启动 加入开机启动 systemctl enable firewalld.service 关闭开机制动启动 systemctl disable firewalld.service]]></content>
      <tags>
        <tag>Liunx命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git-diff的方式来实现vimdiff]]></title>
    <url>%2F2018%2F12%2F28%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fvimdiff%E7%9A%84%E6%96%B9%E6%B3%95%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[vim-plug的使用以及vim-diff使用git-diff的算法vim-plug vim-plug是一个简单的管理vim插件的管理工具 使用 运行vim命令，进入界面 :PlugStatus查看当前包的安装情况 :PlugInstall安装包 vim-diff-enhanced插件 使用了git-diff中的patience算法，比起自带的会慢一点，但显示更加友好 在.vimrc文件中加入下面的代码行 123" 前提是使用vim-plug管理工具的时候，其他包管理工具请查看官网" https://github.com/chrisbra/vim-diff-enhancedPlug 'chrisbra/vim-diff-enhanced' vim打开界面，开始执行安装PlugInstall 后面如果有diff文件情况下，在执行完vimdiff a b后，可以在界面中执行PatienceDiff，就能看到新的展示 修改默认的diff方式 将下面的代码块加入.vimrc中 1234" started In Diff-Mode set diffexpr (plugin not loaded yet)if &amp;diff let &amp;diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'endif]]></content>
      <tags>
        <tag>Linux命令级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的mpi4py多进程实现]]></title>
    <url>%2F2018%2F12%2F26%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fcentos%E4%B8%8A%E5%AE%89%E8%A3%85mpi%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[centos中安装mpi模块来实现并发 Message Passing Interface，信息通讯接口，一般使用python中的mpi4py包来达到调用c++程序中的mpi模块的操作 安装mpi 这里尽量不要安装openmpi，尝试安装结果发现无法运行 yum list mpich*可以看到有多个包，可以选择一个版本来安装 yum install -y mpich-3.2* 安装mpi4py pip install mpi4py安装包即可 调用方式 和一般的调用方式不一样，必须使用mpi的命令来执行python程序 12345678910111213from mpi4py import MPIimport numpycomm = MPI.COMM_WORLDsize = comm.Get_size()rank = comm.Get_rank()a_size = 1senddata = (rank+1)*numpy.arange(size,dtype=int)recvdata = numpy.empty(size*a_size,dtype=int)comm.Alltoall(senddata,recvdata)print(" process %s sending %s receiving %s" % (rank , senddata , recvdata)) 123456789# 启用5个进程来跑该程序mpirun -n 5 python m.py# output process 0 sending [0 1 2 3 4] receiving [0 0 0 0 0] process 1 sending [0 2 4 6 8] receiving [1 2 3 4 5] process 2 sending [ 0 3 6 9 12] receiving [ 2 4 6 8 10] process 4 sending [ 0 5 10 15 20] receiving [ 4 8 12 16 20] process 3 sending [ 0 4 8 12 16] receiving [ 3 6 9 12 15]]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask中的错误处理器]]></title>
    <url>%2F2018%2F12%2F18%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fflask%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[flask中的错误处理器 对abort的一种补充 优化状态码展示的效果12345from flask import render_template@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404 转换掉应用中所有的异常 优化异常捕获的效果下面的代码即是展示了错误捕获的转换，当该错误有自定义的时候，那么直接转换成自定义的这一部分；如果不存在自定义的类型，那么直接就使用通用的一个异常 12345678910from flask import jsonifyfrom .errors import BaseExc@site.errorhandler(Exception)def coupon_api_exception(error): if isinstance(error, BaseExc): return jsonify(&#123;'status': 'error', 'message': error.message&#125;), error.status_code return jsonify(&#123;'status': 'error', 'message': '系统异常'&#125;), 500 1234567891011121314151617181920# 自定义异常class BaseExc(Exception): message = '系统异常' status_code = 500 def __init__(self, msg=None): self.message = msg or self.message def __str__(self): return self.messageclass SystemException(BaseExc): message = '系统异常' status_code = 500class TimestampOutException(BaseExc): message = '时间戳超过有效范围' status_code = 500]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中枚举的使用]]></title>
    <url>%2F2018%2F12%2F09%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fpython%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举在应用中的重要性 最近在重构一部分别人的代码时候发现，很多应用中的常量都是写到了数据库中，然后在代码中获取对应的值来判断各种状态值以及属性，这就导致了在排查的问题时，需要不停地针对代码中的各种状态值，再去看下数据库具体代表了什么状态，影响排查的进度，也给后续的开发造成了困难 枚举 代表了一系列常量的集合 python中的枚举 python在3.4版本中加入了enum标准库 enum 提供了 Enum/IntEnum/unique 三个工具，可以通过继承 Enum/IntEnum 定义枚举类型，其中 IntEnum 限定枚举成员必须为（或可以转化为）整数类型，而 unique 方法可以作为修饰器限定枚举成员的值不可重复 123456789101112from enum import Enum, IntEnum, unique try: @unique class WEEKDAY(Enum): MON = 1 TUS = 2 WEN = 3 THU = 4 FRI = 1except ValueError as e: print(e) 更为重要的是python中的枚举，所有的对象都是单例模式，无法实例，无法更改，只能将对象赋值给变量 123456789101112131415161718192021from enum import IntEnumclass UserSource(IntEnum): DEL_USER = 4 DISABLED_USER = 3 NORMAL_USER = 2if user_status == UserSource.DEL_USER: # 删除帐号 res = HandleSso.del_user(user_id, op_user_id)elif user_status == UserSource.DISABLED_USER: # 禁用/未激活 status = 2 res = HandleSso.put_user_status(user_id, op_user_id, status)elif user_status == UserSource.NORMAL_USER: # 正常用户 status = 1 res = HandleSso.put_user_status(user_id, op_user_id, status)else: return jsonify(&#123;"message": '参数错误'&#125;) 更多的学习 如果对python中的元类和单例有深入学习的想法，查看Enum的源码是最快的方式]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装以及部署基本服务]]></title>
    <url>%2F2018%2F12%2F04%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fcentos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[安装centos系统安装系统/开启网络 https://mirrors.aliyun.com/centos/7.5.1804/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso安装镜像盘 电脑开始安装，需要注意的是中途会让你填写安装到哪个磁盘，是否要清楚数据以及设置帐号密码功能 完成后就可以重启电脑，登录密码 默认是没有开通网络功能的，需要手动开启/etc/sysconfig/network-scripts/ifcfg-***文件中的ONBOOT=yes,然后重启 安装python3虚拟环境 使用pyenv和pyenv-virtualenv插件配合使用 安装依赖包 1yum install -y gcc git openssl-devel zlib-devel readline-devel sqlite-devel bzip2-devel patch libffi-devel 安装pyenv 1git clone git://github.com/yyuu/pyenv.git ~/.pyenv 安装pyenv-virtualenv插件 1git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv 写入环境变量 1234export PYENV_ROOT="$HOME/.pyenv"export PATH="$PYENV_ROOT/bin:$PATH"eval "$(pyenv init -)"eval "$(pyenv virtualenv-init -)" 安装python3，并启动虚拟环境 123pyenv install 3.7.0pyenv virtualenv 3.7.0 py3pyenv activate py3 安装mysql和redis安装mysql1234567891011121314151617# 更新源yum install wgetwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum update# 安装mysql-serveryum install mysql-serversystemctl start mysqld # 默认bind的是127.0.0.1，需要手动开启外网访问# 默认root账户没有密码# 登录进mysql执行下面的命令use mysqlGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root';FLUSH RIVILEGES 安装redis12345678yum install epel-releaseyum updateyum install redis# 启动服务systemctl start redis# 外网访问，修改redis.conf, 把本机ip加入进去bind 127.0.0.1 10.10.29.244]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps必备关注]]></title>
    <url>%2F2018%2F11%2F24%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2FVPS%E5%BF%85%E5%A4%87%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[vps上安装v2ray记录 记录下安装v2ray，开起weboscket+nginx+tls模式来隐藏真实信息 v2ray 国内一波大神搞得，使用vmess协议加密传输，支持shadowsocks 一键安装脚本1https://github.com/233boy/v2ray 自行安装 时间校对(很重要) 对于 V2Ray，它的验证方式包含时间，就算是配置没有任何问题，如果时间不正确，也无法连接 V2Ray 服务器的，服务器会认为你这是不合法的请求。所以系统时间一定要正确，只要保证时间误差在一分钟之内就没问题。如果时间不准确，可以使用 date –set 修改时间 1$ sudo date --set="2018-11-22 16:16:23" 安装脚本 12345678wget https://install.direct/go.shsudo bash go.sh# 启动systemctl start v2ray# 升级sudo bash go.sh 配置文件 json的格式 /etc/v2ray/config.json 配置如下，关键点就在于inbound和outbound，有shadowsocks的需求加一个streamsetting12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; "port": 12345, # 通讯端口，客户端和服务端一致，自定 "log" : &#123; "access": "/var/log/v2ray/access.log", "error": "/var/log/v2ray/error.log", "loglevel": "warning" &#125;, "inbound": &#123; "protocol": "vmess", "settings": &#123; "clients": [ &#123; "id": "293c95b0-a4a2-47d5-b6eb-da8e6894e7b8", # UUID 在这个网站随机生成一个，https://www.uuidgenerator.net， 要保证client和server配置一个UUID "alterId": 55, # 这个自定，数字范围0-100，但要保证客户端和服务端一致 "level": 1 # 官方说明，0 共享VPS, 1 自用VPS &#125; ] &#125; &#125;, "outbound": &#123; "protocol": "freedom", "settings": &#123;&#125; &#125;, "inboundDetour": [ &#123; "protocol": "shadowsocks", # 此段为支持SS协议部分 "port": 1234, "settings": &#123; "method": "chacha20", # 加密协议支持aes-256-cfb, aes-128-cfb, chacha20 (V2Ray 1.9+), chacha20-ietf (V2Ray 1.9+) "password": "v2ray", "udp": false # 是否支持UDP中转 &#125; &#125; ], "outboundDetour": [ &#123; "protocol": "blackhole", "settings": &#123;&#125;, "tag": "blocked" &#125; ], "routing": &#123; "strategy": "rules", "settings": &#123; "rules": [ &#123; "type": "field", "ip": [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "::1/128", "fc00::/7", "fe80::/10" ], "outboundTag": "blocked" &#125; ] &#125; &#125;&#125; 客户端下载 Mac上直接使用v2rayN ios上使用小火箭 没什么难度，只是需要根据你服务器上配置的协议来配置客户端即可 客户端装好后，chrome需要配置export参数才能使用代理，不方便Mac上配合surge来实行全局控制 v2ray的客户端监听的socks端口可以让surge配置一条proxy记录 1socks5,127.0.0.1,1080 使用websocket+nginx+tls来混淆，防止被GFW监听 主要原理就是利用了tls的加密，模仿正常的网站访问即可 需要准备一个域名(子域名也可以)，并将之A类解析到自己对应的服务器上v2-&gt;x.x.x.x安装nginx/下载证书 使用acme脚本来辅助申请，3个月有效期，到时需要重新续约 1https://github.com/Neilpang/acme.sh nginx配置文件 1234567891011121314151617server &#123; listen 443 ssl; ssl on; ssl_certificate /etc/v2ray/v2ray.crt; # 证书 ssl_certificate_key /etc/v2ray/v2ray.key; # 证书 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; server_name mydomain.me; location /ray &#123; # 与 V2Ray 配置中的 path 保持一致 proxy_redirect off; proxy_pass http://127.0.0.1:10000; # 假设WebSocket监听在环回地址的10000端口上 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $http_host; &#125;&#125; 针对h2的配置和上面类似套cdn，由于国内域名需要备案才能使用，放弃；可以使用cloudfare，但连接速度也许更慢 开起bbr加速 google开发的阻塞控制算法，针对tcp的连接能有效降低丢包概率centos7的机器中，默认内核是3.9.*，先要升级到4.19以上才行 升级内核12345678rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org # 加入key到yum中rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm # 添加源yum --enablerepo=elrepo-kernel install kernel-ml # 安装最新的内核grub2-set-default 0 # 0号位需要启动的内核，默认安装内核均是0reboot # 不重启不生效 # 查看内核版本uname -r # 看是否是4.19.4-1.el7.elrepo.x86_64 开启bbr12345678echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf# 保存执行sysctl -p # 查看是否成功lsmod | grep bbr]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac外放没有声音]]></title>
    <url>%2F2018%2F11%2F24%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fmac%E5%A4%96%E6%94%BE%E6%B2%A1%E6%9C%89%E5%A3%B0%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[Mac系统有时候外放没有声音 有时候 Mac 从睡眠状态恢复之后没有声音，这是 Mac OS X 系统的一个 Bug。这是因为 Mac OS X 的核心音频守护进程「coreaudiod」出了问题 解决办法： sudo killall coreaudiod 杀掉该进程即可 重启机器]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ac86u通过公网模拟一个nas]]></title>
    <url>%2F2018%2F11%2F17%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8ac86u%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用华硕路由器ac86u配置简单的公网访问新补充虚拟内存 ac86u的路由内存是个问题，有的时候会由于内存不足导致路由器重启，这个时候可以挂载一个u盘来做虚拟内存(实际上对内存没特别大影响，只是让系统能知道内存足够，可以避免不稳定重启的情况) 使用脚本 1https://raw.githubusercontent.com/mashpolo/myfav/master/sdaswap.sh 放置于路由器目录/jffs/scripts/中，脚本权限755 /jffs/scripts/sdaswap info/start/stop使用 双线双拨 ac86u不支持单线双拨，最简便的方式是重新用一根网线连接路由器和光猫带宽可以叠加 在路由器的外部网络中->双线路打开双线路，设定第二个WAN口和上图一致，如果两条线路带宽一致，直接可以1:1的负载，这里实际是将一个路由器的LAN口虚拟成了WAN口 重启路由器 使用新网线连接路由器和光猫，插入的路由器LAN口必须是你上面设置的那一个 开始拨号即可，注意的地方就是选择正确的网络设置，如下图 外接硬盘 默认url都是192.168.50.1 将硬盘插入usb3.0 开起aicloud 在路由器里面的AiCloud中开起云端硬盘 开起samba和ftp共享硬盘 在usb相关应用中的服务器中心开启 默认ftp://192.168.50.1可以看到你硬盘中的东西 开起公网访问光猫申请桥接模式 四川电信直接在189官网打开即可 使用了桥接模式以后，可以在路由器上通过宽带帐号密码拨号上网 路由器上能看到WAN IP是内网的 申请公网ip 直接qq客服要求开通即可 重启光猫，路由器重新拨号，能看到公网ip 设置ddns 将用户的动态ip(电信给的都是动态的ip，重启就变)绑定到一个域名上，这样通过域名访问，不管ip怎么变，都能看到这个地址 华硕路由器刷梅林固件(koolshre论坛上有) 直接在页面上通过上传固件升级即可 升级完成后，需要打开软件中心升级，然后重启路由器 软件中心安装aliddns和let’s encrpt插件 前一个可以使用aliyun上注册的域名，需要申请自己的appkey和appsecret 后一个是安装ssl证书 aliddns的使用 该插件主要为了方便使用自己在阿里云上注册的域名来绑定ip 创建子域名，然后绑定到自己的ip上 使用该插件需要在阿里云上开起accesskey的服务，然后拿到key和secret 如果使用的域名解析使用的是腾讯的dnspod，需要在dnspod.cn上生成一个api，拿到id和token，和上面一样存储进插件即可 注意 这里需要注意的是，由于在梅林中，aicloud的web服务是基于lighttpd的，证书文件的位置在/etc下面，因此每次部署新的ssl证书以后，需要重启服务service restart_webdav let’s encrypt插件 主要是用来生成证书 一键生成，会自动配置到路由器上 开起公网访问 在路由器系统管理->系统设置中，授权方式使用https，一般端口默认是8443，想换就换，如果不想通过公网访问路由器设置，那就不需要换 在Installed Server Certificate一栏可以看到通过插件申请的证书已经生效，并绑定到自己的域名上，那么可以通过公网访问该域名来使用AiCloud了]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ的消息确认]]></title>
    <url>%2F2018%2F11%2F16%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitMQ%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[rabbitmq的简单介绍 一个消息队列，可以持久化到磁盘，消息存储在内存中生产者推送消息到队列中，消费者从队列中拿出一条消息进行消费先进先出 消息丢失消息丢失 amqp协议支持的事务模式 和关系型数据库的事务类似，支持交易模式开起，提交事务，回滚的方式 事务提交非常慢，会严重降低系统吞吐量 确认模式 异步的方式 消费后发起回调告诉rq，然后rq才从内存中删除该消息 如果丢失，消息会回到队列中 分为自动确认模式和手动确认 自动确认更快捷，但不安全，如果在成功发送之前，消费者的TCP连接或通道关闭，服务器发送的消息将丢失。在使用自动确认模式时，需要考虑的另一件事是消费者过载 手动确认模式可以使用 prefetch，限制通道上未完成的（“正在进行中的”）发送的数量。然而，在自动确认的情况下，没有这样的限制 如果忘记确认，会导致内存爆满autoack为False，消息会分成两个部门，一部分是代分配的任务，一部分是没有确认的消息]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面优化概述]]></title>
    <url>%2F2018%2F11%2F12%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fweb%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[web页面的优化压缩代码 常规做法，减少js文件的大小 包括js，css，html的代码 script标签的优化 由于scrpit标签中的东西会影响浏览器渲染dom，一般是页面load的时候，浏览器会开始加载并生成dom树，但发现script标签后，会停止渲染并开始下载脚本，然后再渲染 12&lt;script './f.js' async&gt;&lt;/script&gt; //下载完就开始执行&lt;script './f.js' defer&gt;&lt;/script&gt; //更安全的方式，所有的脚本下载完才开始执行 分离一个大的js文件 减少冗余的代码块和js文件 使用包管理工具，webpack等工具，对代码进行分离，更多的使用import的方式来避免重复的代码块 分离css为重要和不重要的 在开始加载页面的时候，接口数据已经返回并显示在屏幕上，但是页面渲染还没有完成，就会给用户造成体验不好的感觉 将重要的css代码快嵌入到html中 不重要的css代码使用link标签 不重要的css，移除不正确的显示以及看起来很酷的东西 使用gzip的方式发送数据包 图片，字体，视频以及二进制文件不需要压缩了，已经压缩过了，否则会消耗更多的时间，svg除外 部署cdn服务 可以减少资源包下载的时间 提前加载12345&lt;link ref="dns-prefetch" href="//example.com"&gt; //写好哪一个cdn更快&lt;link ref="preconnect" href="//example.com"&gt; //&lt;link ref="prefetch" href="/style.css" as="style"&gt;&lt;link ref="preload" href="/style.css" as="style"&gt;&lt;link ref="prerender" href="//example.com"&gt; 图片的选择 svg 一般用在图标 Jgp 对照片而言，压缩后失真少 Png 不需要对质量要求很高的时候 webp 同时执行高压缩，失真少的情况， jpg+png Gif 最大的，少使用]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决mysql的升级冲突以及docker服务需要修改的配置]]></title>
    <url>%2F2018%2F11%2F08%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fmysql%E5%8D%87%E7%BA%A7%E5%88%B08%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Adocker%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[mysql升级到8.0造成的问题 mysql从5.7升级到8.0以后帐号系统发生错误 1The user specified as a definer (&apos;mysql.infoschema&apos;@&apos;localhost&apos;) does not exist 解决方式：1mysql_upgrade -u root -p; 由于docker服务要连上docker外部的服务，比如说是mysql,redis之类的，需要将外部基础服务绑定的ip改为0.0.0.0，这样所有的其他服务都可以使用ip地址来使用该服务 12mysql中 my.conf bind-address=0.0.0.0redis中 redis.conf 在bind后面加入0.0.0.0]]></content>
      <tags>
        <tag>技术问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在crontab中启用虚拟环境]]></title>
    <url>%2F2018%2F11%2F08%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%9C%A8crontab%E4%B8%AD%E4%BD%BF%E7%94%A8python%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在crontab中使用python虚拟环境 由于crontab启动的进程默认不会加载当前的环境，所以需要手动执行一边source的命令，然后进入该目录，启动虚拟环境 在centos启动定时任务的时候，需要加入以下的改变环境变量的办法 123. ~/.bashrc #设置环境变量的文件cd ~/wx_smzdm #跳转用户目录pyenv activate py3 #进入虚拟环境]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构笔记]]></title>
    <url>%2F2018%2F11%2F06%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[微服务架构 最外层的openapi 主要用于鉴权所有对外的接口都要经过这一层 控制中心-airflow 管控所有请求的走向下面的请求如果有一个由于鉴权失败或其他原因拿不到数据，由控制中心决定是否放弃或者下降至另外一个接口所有内部服务之间使用动态token来鉴权 组合数据 组合各种数据拿到基础服务得到的数据后，以及对接的第三方数据，合并成一个数据源交给上层 基础服务 功能模块 meta服务 对文件存储封装的一层服务基础服务不直接操作数据的存储 文件存储 数据的存储]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask中的上下文]]></title>
    <url>%2F2018%2F10%2F29%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fflask%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[flask中的上下文介绍详情阅读 Flask 是一个基于 Werkzeug 实现的框架，所以 Flask 的 App Context 和 Request Context 也理所当然地基于 Werkzeug 的 Local Stack 实现因为 Local Stack 的状态是线程隔离的，而 Web 应用中每个线程（或 Greenlet）同时只处理一个请求，所以 App Context 对象和 Request Context 对象也是请求间隔离的。 app上下文 应用级别的上下文，主要用在连接数据库，redis等全局操作 启动request，每次返回结果销毁request上下文request上下文 请求级别的上下文，用于访问资源 理解environ,headers,data,args的区别 environ代表了wsgi服务中的每个请求的环境参数，包含了headers相关的东西 headers，主要是客户端发起请求的header参数 data主要是body中的参数 values包含了args和form中的字段 argsurl中的请求参数]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask-socketio模块的使用]]></title>
    <url>%2F2018%2F10%2F20%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2Fflask-socketio%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[flask-socketiogithub socket.io框架使用的是websocket协议，服务端和客户端都可以向对方发送请求，常见环境是聊天室，异步任务返回结果 以前 前端长轮询来获取某个任务的结果，比较耗资源 使用websocket协议 双方都可以发起请求 也是基于http协议 使用方式 首先需要设定异步服务的方式，推荐依次是：eventlet->gevent->theading 判断使用什么消息队列，redis/rabbitmq->kombu模块支持的消息队列均可以 对于flask而言，启动方式类似 12socketio = SocketIO(app, message_queue=f'redis://localhost:6379/1', async_mode='gevent')socketio.run(app, '10.10.21.145', port=1233, debug=True) 使用socketio的时候，消息以事件的形式被双方接收。客户端使用Javascript的回调函数，服务端需要为事件注册处理函数，就像在视图中注册路由处理函数那样。 使用on关键字来建立事件处理函数，支持返回数据供客户端回调使用 SocketIO事件处理函数可以通过调用send()和emit()函数来向链接的客户端发送回应消息，使用broadcast=True来实现对每一个命名空间下的链接批量发送消息 Flask-SocketIO通过join_room()和leave_room()函数来实现每个链接的独立性 connect和disconnect事件分别代表建立链接和断开 部署使用gonicorn 当在gunicorn中使用gevent worker和WebSocket时，启动命令必须指明使用支持WebSocket的gevent worker: 1gunicorn --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker module:app 使用uwsgi uwsgi提供的参数必须使用websocket和ssl编译，才能供websocket使用 1$ uwsgi --http :5000 --gevent 1000 --http-websockets --master --wsgi-file app.py --callable app]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠须管常用到的配置项]]></title>
    <url>%2F2018%2F10%2F20%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E9%BC%A0%E9%A1%BB%E7%AE%A1%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[rime-鼠须管输入法常用配置 从图标的用户设定可以定位到具体目录~/Library/Rime/xxx 全局配置文件 default.yaml default.custom.yaml (一般自己创建，优先级高于默认文件) 控制切换中英文切换 inline_ascii：在输入法的临时西文编辑区内输入字母、数字、符号、空格等，回车上屏后自动复位到中文。 commit_text ：已输入的候选文字上屏并切换至西文输入模式。 commit_code ：已输入的编码字符上屏并切换至西文输入模式。 noop ：屏蔽该切换键。123456789ascii_composer: good_old_caps_lock: true switch_key: Caps_Lock: commit_code Control_L: noop Control_R: noop Eisu_toggle: clear Shift_L: commit_code Shift_R: commit_code 配置特定的环境 squirrel.yaml squirrel.yaml (和上面类似，优先级高于默认文件) 对某些app关闭默认中文(对应的app名字从该app的Info.plist中查找) /Applications/PyCharm.app/Contents/Info.plist12345678910111213141516171819app_options: com.alfredapp.Alfred: ascii_mode: true com.apple.Terminal: ascii_mode: true no_inline: true com.blacktree.Quicksilver: ascii_mode: true com.googlecode.iterm2: ascii_mode: true com.jetbrains.pycharm: ascii_mode: true com.sublimetext.3: ascii_mode: true "com.runningwithcrayons.Alfred-2": ascii_mode: true org.vim.MacVim: ascii_mode: true no_inline: true]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《穷爸爸富爸爸》笔记]]></title>
    <url>%2F2018%2F10%2F09%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8%2F</url>
    <content type="text"><![CDATA[读《穷爸爸富爸爸》笔记学会让钱为我工作 寻找一份工作不能简单的为了钱 利用手上的资源来创造钱，如果能持续的生钱才是最好的 职业并不是事业 保证你手上的每一块钱都是你的雇员，能让他自己产生收益，这就是投资最简单的理解方式 合理避税 富人通过开公司来避税，因为公司缴税的部分是收入-消费-缴税，缴税的部分已经很少了 穷人是收入-缴税-消费，这就是穷人越来越穷的原因 什么是财商 财务知识，能阅读理解数字的含义 投资的策略 市场供给和需求 法律规章 成功所必须的管理技能 对现金流的管理 对系统（自身，时间）的管理 对人员的管理 克服最致命的困难 对有可能亏钱的恐惧，每个人都害怕失败，但没有失败就不会成功 愤世嫉俗，大部分人都怨天尤人，缺乏挑战的勇气，人云亦云，也就是缺乏主见 懒惰，缺乏动力，不要总是我做不到，而是应该通过哪方面的努力能做到，欲望才是提高生产力的原动力 习惯，学会投资自己，优先提升自己，雪球才会越滚越大 傲慢，傲慢是自大和无知的结合体，满嘴跑飞机，攀比，炫耀阻碍人的成长 开始行动 来自于脑海深处的力量，称之为本能就更好了 选择，懂得投资头脑，知识才是最大的财富 维系好关系，三人行，必有我师焉，从朋友那里也许能比市场更快获取到某些消息 快速学习，在一个天天都有不断的新知识的时代，比别人快一秒掌握知识，就能获得成功 自律，如果控制不了自己，那么就不可能致富，最重要的3个管理技能，现金流，人事和个人时间的管理 懂得接受好的建议，专业的事情交给专业人士去做，不要舍不得为专业人士付的钱，这能为你带来更多 无私，不要仅关注投资回报率，更好关注，收回投资后賺到的资产 专注，通过对自己消费欲望的刺激来不断激励自己通过理财去获取 偶像的力量，从各种名人身上学到有用的东西 懂得先给予才有收获的道理，“舍得”]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关心自己的成长，不仅仅是技能]]></title>
    <url>%2F2018%2F10%2F07%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%88%90%E9%95%BF%2F</url>
    <content type="text"><![CDATA[从初级工到熟练工详细信息 改变思维，提高软技能 常规的 写代码 审核代码，不仅仅是自己的，还有别人的 审核，甚至编写设计文档(api，有些是前端的设计稿) 团队协作处理问题(不是帮助别人直接解决问题，而是应该一起协作来处理，提供思路，不提供直接的算法) 内敛的 把控项目的质量(不要直接指出别人的错误，提供一些额外的信息即可，可用性/扩展性/安全) 新项目的发起 把控项目的进度 积极主动的处理项目中的风险 成功的沟通 做有益于团队/公司的小项目(开发公共模块，提高项目开发效率，减少重复代码等) 时刻要关注到项目和运营的联系所在，要知道盈利点在什么地方 决定什么时候停止一个项目 更需要关注的(管理者需要注意的) 确保部门中的每个人都能清晰的认识到自己的工作 确保工作都是公平的分配到每一个人 确保代码的开发和合并没有问题 团队氛围保持良好 培训新员工，帮助他尽快融入团队中 项目的管理 和产品经理一起对项目保持关注 周会，确定项目中的问题 为你的工作明确一个界限 学会说不 我想做这个，符合我自身的发展 对团队更好 拒绝你不能做的/不想做的 也许雇佣新的人来做，对于项目来说更有效率]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改aws上centos7机器的默认ssh登录端口]]></title>
    <url>%2F2018%2F09%2F19%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E4%BF%AE%E6%94%B9aws%E4%B8%8Acentos7%E7%9A%84ssh%E7%99%BB%E5%BD%95%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[重置aws上的ssh默认登录端口 aws上的ec2机器，默认ssh的登录都是22，为了防止被黑，记录下修改该默认端口的方法 修改/etc/ssh/sshd_config文件,将Port 22注释去掉 在上面的文件中，加入一行，你想要增加的端口号，格式和22一致 注意：针对centos7centos7上的内核加入了安全机制，可以通过semanage port -l | grep ssh命令查看，如果看到当前端口只有22，那么需要将你添加的端口号加进去，semanage port -a -t ssh_port_t -p tcp xxx;如果想删除端口号，使用命令semanage port -d -t ssh_port_t -p tcp xxxx即可 重启sshd服务，systemctl service sshd 注意 还需要到亚马逊的管理界面上，针对服务器添加一个安全组,如下 设置完后，即可开始测试，使用你设定的端口号开始登录服务器 如果确定都没问题，那么回到服务器上，注释掉sshd_config文件中的Port 22,重启sshd服务 到aws的管理界面上，把安全组对22的那一行删除即可]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac上的sed使用记录以及安装gnu的工具集]]></title>
    <url>%2F2018%2F09%2F18%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fmac%E4%B8%8A%E5%AE%89%E8%A3%85gnu%E7%9A%84%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[mac上的工具集以及安装gnu的工具集mac上的sed命令 使用sed -i命令修改文件时，在mac上需要在-i后加入’.bak’参数，类似对你要修改的文件进行一次备份 12345$ sed -i 's/hello/hello2425/' testsed: 1: "test": undefined label 'est'$ sed -i '.bak' 's/hello/hello2425/' test# 当前目录下会生成一个test.bak文件，是对老test文件的备份，test文件已经修改好 扩展阅读 安装gnu的工具集 安装coreutils export PATH=&quot;$(brew --prefix coreutils)/libexec/gnubin:/usr/local/bin:$PATH&quot;把这个环境变量加入.zshrc/.bashrc， export MANPATH=&quot;/usr/local/opt/coreutils/libexec/gnuman:$MANPATH&quot;这个环境加入到系统环境文件中后，可以直接使用man命令来获取到新安装命令中的信息 添加brew的repo，brew tap homebrew/dupes (如果你的homebrew版本高于1.5，那么可以直接跳过)-&gt;brew config|grep VERSION 安装gnu的工具集 1234567891011121314151617# --default-names代表不希望homebrew预加gs到新安装的命令，相当于直接覆盖老的mac命令brew install binutilsbrew install diffutilsbrew install ed --default-namesbrew install findutils --default-namesbrew install gawkbrew install gnu-indent --default-namesbrew install gnu-sed --default-namesbrew install gnu-tar --default-namesbrew install gnu-which --default-namesbrew install gnutls --default-namesbrew install grep --default-namesbrew install gzipbrew install screenbrew install watchbrew install wdiff --with-gettextbrew install wget]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web应用基本架构]]></title>
    <url>%2F2018%2F09%2F17%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fweb%E5%BA%94%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[web应用基本架构基本结构图 dns 用户发出的请求通过dns服务器，通过用户发起的域名对应到具体的应用地址，简单一点的来讲，就是一个域名和应用ip地址一个对应的键值服务 负载均衡 对应并发量很大的web应用，需要生成多个应用实例，大批量的请求来临时，通过负载均衡，就这些请求分发给不同的服务器，这些服务器应用都是一样的，可以简单理解为就是多个镜像，避免单个服务器过载 web应用 处理核心的业务逻辑，用户的请求，返回用户html代码，处理这些任务便是与后台基础设施间通信，比如数据库、缓存服务、任务队列、搜索服务、其它微服务和消息/日志队列等等。一般情况下至少两个应用服务器，或者更多，这些应用服务接入负载均衡，处理用户请求 数据库服务器 web应用都有对应的一个或者多个数据库来存储消息，一般web 应用服务器与一个数据库进行直接通信，任务服务器同理。另外，每个后台服务都有一个自己的数据库，并与其它的应用隔离(现有的分布式数据库，可以一个应用对应一个数据库集群) sql数据库 结构化查询语言，简单易用(大部分只支持纵向的扩展，成本很高) nosql数据库，用来应对大规模 web 应用中的海量数据(横向扩展非常容易) 缓存服务 缓存服务提供一种简单的键值对数据存储，使存取信息时间复杂度接近 O(1)。一般用来缓存计算成本很高的运算结果，用户经常访问的数据等 redis memcache 任务队列 任务队列。它包含两部分：正在运行的任务队列，和一或多个处理任务的服务器（通常称为 workers），最简单的调度即是FIFO，现在一般应用根据自身设定的规则(调度算法)来执行任务减少前端的响应时间，不直接影响用户的请求 全文检索服务 主要目的是为用户提供全文搜索的功能。对用户输入执行查询的时候能较快返回相近的结果(倒排索引)通常我们会跑一个单独的“搜索服务”计算并存储倒排索引，并提供查询接口 ElasticSearch 微服务 应用达到一定规模后，通常会拆分成单个微服务，服务之间互相通信 大数据 在应用到达一定规模时规范数据流程，ETL的过程 数据加工 应用响应用户交互事件，将数据发送到数据流处理平(利用kafka等消息队列来传递数据流) 数据存储 原始数据和转换加工后的数据在云端存储 数据分析 转换加工后的数据会加载入数据仓库来做后续分析(hadoop的MapReduce技术) 云存储 简单，扩展方便，用户获取更便捷。任意在本地文件系统存储的文件，你都可以通过云存储存取，并用 HTTP 协议通过 RESTful API 访问并交互。 CDN 内容分发网络，主要目的是将存储数据保存在世界各地的节点上，让不同地域的人使用该服务都能获得很好的效率]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对应用，server的简单解析]]></title>
    <url>%2F2018%2F09%2F15%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2F%E5%AF%B9%E5%BA%94%E7%94%A8%E5%92%8Cserver%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[nginx，gunicorn，web appflask 一个web framwork，当然，也可以使用他内置的wsgi server来供给用户访问，但是，同一时间只能有一个http请求在处理，对于实际生产环境中来说，限制太大了主要是定义了一个键值对的概念，每个键值就是一个url-&gt;返回数据(响应码，headers，和具体的数据) gunicorn 可以建立多个sockets连接请求，将对应的http请求内容发给对应的应用实例为了解决同一时间并发的请求，相对于web app内置的wsgi server来说，更简单 nginx 负载均衡层，最大的作用是能启用https一个静态web服务器，放在gunocorn前面主要是为了转发请求到对应的server，也就是负载均衡的概念]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员应该铭记的知识点]]></title>
    <url>%2F2018%2F09%2F08%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[程序员应该时刻铭记的话资料来源 开发层面上看 程序不仅仅是用来执行的，它还是一种向团队其他人描述解决问题的方法。可读性强的程序不是雪中送炭，而是一份完美的代码应该的表现。包括代码逻辑清晰，变量名规范以及必要的注释等。 不要过于关注你为你的晋升做了多大的贡献，更多的是要为你的团队和客户考虑，你这次为他们做了多少贡献。尽量避免过于显眼的表现。在你没有完全弄懂产品的目的之前不要开始写代码。 保持对代码简洁性的追求，让自己的代码保持简洁，易于旁人理解。 敢于说不，并不是所有的需求都需要上，每个需求都会超过第一次设计时的预算开支。维护代码的开支，文档和用户对新功能的熟悉，都是一笔不小的开支。所以，敢于说不，通常大部分情况下，这些需求都是不重要的。 对用户的请求，不要总是不计后果的接收。每个用户都有自己的爱好，程序只能满足大部分人的需求，而不是所有人。对于某些请求而言，加入后续的迭代，在开发过程中来全盘考虑是否合适更好。 对你的项目做好持续集成，并且保持完整的单元测试覆盖率。确保你在一个安全的环境中修改代码，如果你觉得这不是一个大问题，那么请把注意力放在搭建正确的开发环境中。 没有提前做好准备不是什么大问题，尝试开发过程中来看结果也是可以接受的，但尽早回到正确的道路上。确保你有一个和生产环境一模一样的测试环境。 好的程序都是减少繁琐的事情，问题看起来复杂，不代表解决问题就很困难。不要过于为你程序加上时髦(新颖)的技术，这样并不会带给你的程序多大的优势，解决问题的方法尽可能简单。 将重复的代码模块化，这样既能提高效率，团队中其他人也能有效利用这部份代码。尽量将重复的事情自动化。 在开始设计的时候，你就需要考虑到这个产品希望带给用户什么，能获得多少的利润，是否会有用户不希望的点，后续怎么在保持原有功能的基础上来修改这些。 接口设计方面 不管你是不是有经验的开发者，在设计你的接口的时候，都需要考虑到，这部份接口不仅仅你要知道使用，更需要让其他人能清晰明了的知道。 能自动化的尽量自动化，尽量减少面对用户的方法和给用户的选择。保持简单的设计，让人一看到就明白该怎么使用就行了。 简单的事情就简单化处理，不要给用户一种需要花大把时间来考虑你为什么这样设计。 如果你的代码足够简洁，那么别人甚至不需要阅读文档就能清楚的知道你这部份代码做了什么。 设计的接口能简单明了的让人知道这部份代码是干什么的。大部分阅读你的代码，都是通过看小一部分代码例子或者单元测试，来分析你这部份代码是怎么运行的。 接口的目的就是为了解决问题，而不是为了提现底层是怎么运行的。 一个好的接口设计应该是层次分明的，利于理解和富有效率。 接口实际上是你底层数据结构的一个封装，为了构造一个好的接口，你需要根据你手上具体的项目来设计你的数据结构。 设计接口最重要的原则在于，你设计的这个接口是为了切实满足解决一个具体的问题，呃不是一个有可能用户会使用的原因。 为你的接口做好抛出错误信息的准备，这样一旦出问题，你能很快的定位并修复 接口中命名规则要保持一直，不要在上一个接口的变量命名，到了另外一个方法中就是截然不同的意义，容易为别人理解代码造成误解(甚至包括你自己) 一个好的文档带给你的，远超过你设计更多接口的花销 接口文档是用来描述你这个接口应该如何调用，里面最核心的功能是什么，以及使用范例 职业规划方面 职业晋升在于，如果没有你，工作就不能继续进展(或者处于核心位置)。并不是你手下管理了多少人。 软件开发是一个集体活动，你需要在这个团队中时刻和周围其他人保持密切的关系，这和你技术能力一样重要 始终谨慎而明确地表达您希望您的选择支持的价值观，将您的价值观融入您的创作中，不要以为你的作品有问题在于使用的人，你构建它的方式决定了它的使用。 寻找拓宽你眼界的职业机会，这会让你更清楚的认知到当前社会更需要哪种人才 从周围人的经验中获取到有利于自己发展的因素。 不要贪图眼前的利益而忽略长期的发展。 找一家拥有共同价值观和理念的公司对自身而言会更好 高效率的生产力不仅仅代表了编码的速度，更在于质量。这一方面需要长期编码带来的经验，另一方面在于谨慎的态度。错误决策的成本往往比延迟编码的成本更高。 更快地做出决策意味着你可以在职业生涯中做出更多决策，这将使您对可用选项的正确性有更强的直觉。 经验是提高生产力的关键，更高的生产力将为您提供更多的经验 在缺乏第一手资料的时候，选择需要基于你的原则。(自身价值观等)]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的优化策略]]></title>
    <url>%2F2018%2F09%2F02%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2FPython%E7%9A%84%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[python的优化策略更多的使用局域变量，少使用全局变量 更容易维护 一方面，本地域搜索起来更快；另一方面用更短的标识太替代过长的变量名 减少使用函数 判断一个对象的种类，优先使用isinstance, id, type，后面的性能更差 不要把表达式放在一个循环中，这会导致额外的开支 1234567#Each loop needs to re-execute len(a)while i &lt; len(a): statement#Only execute len(a) oncem = len(a)while i &lt; m: statement 引入模块具体方法， 最好使用from…import… 利用字典来优化多个if语句的判断12345678910#if​ reachif a == 1: b = 10elif a == 2: b = 20...#dict reach，better performanced = &#123;1:10,2:20,...&#125;b = d[a] 直接迭代具体的元素123456789a = [1,2,3]#Iterate elements for item in a: print(item)#Iterate indexesfor i in range(len(a)): print(a[i]) 使用迭代器来替换列表等数据 对内存的优化更好 123456#Calculate the number of non-null characters in file f#List analysisl = sum([len(word) for line in f for word in line.split()])#generator expressionl = sum(len(word) for line in f for word in line.split()) 先编译再调用 在使用eval和exec方法时，可以先利用compile命令编译成二进制命令，效率更好尤其是在正则模块中，使用compile来编译成表达式，而不是直接去match 养成模块的好习惯 要养成模块的编程方式，执行代码均放在main函数中，这样在import这个文件的时候，不会直接执行 related links]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2018%2F08%2F21%2F6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fpython%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的遍历实现 二叉树是每个结点最多有两个子树的树结构 遍历的方法 前序遍历，根节点-&gt;左子树-&gt;右子树 中序遍历，左子树-&gt;根节点-&gt;右子树 后序遍历，左子树-&gt;右子树-&gt;根节点 层次遍历，按照层数，从根节点依次往下找 前序，后序，中序都是深度优先遍历的方式 层次遍历是广度优先的遍历方式 使用递归的方式比采用迭代的方式慢递归的方式 前序遍历: 保存当前节点的值，然后递归调用左节点和右节点 后序遍历: 先递归调用左节点和右节点，然后再保存当前节点的值 中序遍历: 先递归调用左节点，保存当前节点值，再递归调用右节点 非递归的方式 前序遍历: 根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。对于任意一个结点node，具体步骤如下： 访问之，并把结点node入栈，当前结点置为左孩子； 判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复上面的步骤直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的） 后序遍历: 使用两个栈来存储左右节点，将每个节点都保存到其中一个栈，然后将该节点的左右节点保存到这个栈，删除在这个栈的节点，保存该节点到第二个栈；然后遍历第二个栈里面的数据，这样才能保证左右节点的值先于根节点保存 中序遍历: 和前序遍历有点类似，把每个节点的左子树存入栈，删除栈中的该节点，保存值。直到左子树节点为空，把右子树作为当前节点。 层次遍历: 使用消息队列，把每个节点都存入队列中，再出队列的时候，依次访问左右子树的根节点值，如果左右子树不为空的情况下，都存入队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#!/usr/bin/env python# coding=utf-8"""@desc: 二叉树@author: luluo@date: 2018-8-22"""import timeclass Node(object): def __init__(self, val='-1'): self.val = val self.left = None self.right = Noneclass Tree(object): def __init__(self): self.root = Node() self.queue = [] # 用来检验当前节点左右子数是否都存在了，不存在的话，这个节点还能继续使用 def add(self, val): """将每个数依次加入到每个节点中，新增一个节点，就这个节点存入队列，直到这个节点的左右树都已满，从队列中删除该节点""" if self.root.val == '-1': self.root = Node(val) self.queue.append(self.root) else: tree_node = self.queue[0] if tree_node.left is None: tree_node.left = Node(val) self.queue.append(tree_node.left) else: tree_node.right = Node(val) self.queue.append(tree_node.right) self.queue.pop(0) def front_sort(self, root): """使用递归的方式来前序遍历""" if root is None: return print(root.val) self.front_sort(root.left) self.front_sort(root.right) end = time.time() def front_sort_stack(self, root): """使用栈的数据结构来保存每次遍历的节点""" if root is None: return stack = [] node = root while node or stack: while node: print(node.val) stack.append(node) node = node.left node = stack.pop() node = node.right def end_sort(self, root): """使用递归的方式来完成后序遍历""" if root is None: return self.end_sort(root.left) self.end_sort(root.right) print(root.val) def end_sort_stack(self, root): """使用栈数据结构来实现后序遍历""" if root is None: return stack = [root] rest_stack = [] while stack: node = stack.pop() if node.left: stack.append(node.left) if node.right: stack.append(node.right) rest_stack.append(node) while rest_stack: print(rest_stack.pop().val) def middle_sort(self, root): """使用递归的方式来实现中序遍历""" if root is None: return self.middle_sort(root.left) print(root.val) self.middle_sort(root.right) def middle_sort_stack(self, root): """使用栈来实现中序遍历""" if not root: return stack = [] node = root while stack or node: while node: stack.append(node) node = node.left node = stack.pop() print(node.val) node = node.right def level_sort(self, root): """使用队列来实现层次的遍历，也就是广度优先遍历""" if root is None: return flag_queue = [root] while flag_queue: node = flag_queue.pop(0) print(node.val) if node.left is not None: flag_queue.append(node.left) if node.right is not None: flag_queue.append(node.right)if __name__ == "__main__": """main function""" test_tree = Tree() for a in range(10000): test_tree.add(a) print('\n\n递归实现先序遍历:') start = time.time() test_tree.front_sort(test_tree.root) end = time.time() print(end - start) print('\n\n非递归，利用栈来实现前序遍历') start = time.time() test_tree.front_sort_stack(test_tree.root) end = time.time() print(end-start) # print('\n递归实现中序遍历:') # test_tree.middle_sort(test_tree.root) # print('\n\n非递归，使用栈来实现中序遍历') # test_tree.middle_sort_stack(test_tree.root) # print('\n递归实现后序遍历:') # test_tree.end_sort(test_tree.root) # print('\n非递归，使用栈来实现后序遍历') # test_tree.end_sort_stack(test_tree.root) # print('\n层次遍历:') # test_tree.level_sort(test_tree.root)]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能的mysql]]></title>
    <url>%2F2018%2F08%2F14%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2F%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[高性能的mysql了解mysql查询过程 客户端发送一条sql请求到缓存中 命中缓存的话，直接返回结果 经过sql解析器，优化器，分解成查询计划 通过存储结构的api，查询计划调用api返回结果，如果命中缓存的机制，也需要缓存这部份数据 返回的数据，有可能是多个数据包，但不可能只保留一部分的数据包 使用了tcp的协议来返回数据包，也就是说是有顺序的 查询语句太长的话，也就说客户端发送的包数据太大，会导致服务端卡死，可以修改max_allowed_packet参数来约定包的大小 尽量避免使用*和多使用limit关键字 查询缓存 预先定义一部分sql语句可以缓存数据，通过sql_cache和sql_no_cache来设置这一部分数据，会缓存到一个hashmap表中，下一次同样的sql语句，就不需要再次解析sql语句等操作 需要sql语句和缓存中定义的完全一直，多一个空格，有注释等都会导致匹配不上 查询语句有包含自定义函数，内置方法，临时表，系统表，用户的变量都会匹配不上 读写操作都会导致性能的消耗，写操作会将之前的缓存数据都清空 读操作由于每次sql语句都会检查一次，并且得到结果还需要缓存，这也需要造成系统的额外消耗 查询机制 mysql解析sql语句，转化成查询计划，寻找最优的一个 最优的并不代表是时间最短的，可以查看show status like &#39;last_query_cost&#39;;来获取上次查询语句的消耗 执行查询计划 通过查询计划，调用底层的api接口来返回数据 返回结果 有可能第一个结果生成就开始返回，这样可以节约资源 优化查询设计表阶段 针对not null字段，只有对该列进行索引了才有效，不然和其他列查询起来是一样的效率 整数型设置宽度没啥用，int都是使用了32位来存储，也就是说int(1)和int(100)是一样的效果 使用浮点数时，可以将浮点数转换成bigint，例如对该值乘以1百万才存储进去，可以节省mysql对浮点数精确计算的消耗 timestamp类型用4个字节来存储，因此只能保存1970-2038年的数据，而datetime类型使用了8个字节，能使用的范围更广 表的列不要太多，查询计划调用api来获取数据，在服务器层需要将这些数据按照列来解码，这个过程很消耗资源 不要对大表来执行alter table，因为这个过程实际上是删除老表，把数据存入新表，再重新建索引，比较耗时间 索引 索引一般使用B树算法来执行，InnoDB使用了B+树,平衡二叉树由于树的高度不会大于1，因此，查询的效率比二叉搜索树更快 二叉搜索树 平衡二叉树 B树 二叉搜索树，左节点 &lt; 根节点 &lt; 右节点，这样的机制能使索引查找最大最小值能容易 B+树 多分支的平衡树 innodb使用该算法，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。 B+树对叶子节点数据存储满的清空下，会使用拆分的操作，也就是从中间把叶节点拆开，n/2 + 1的关键字保存到根节点(如果根节点还有空间的话，否则根节点继续拆分),然后就可以将新数据存储到位置 如果当前叶节点的数据满，但左右两边的叶节点还有空间，会首先来左右移动位置，以方便存储数据 mysql不会使用非独立的列，例如select * from xx where id + 1=4，这个sql语句无法使用索引 前缀索引，如果当前列数据很长，那么只索引部分字段也可以 多列索引，在多个列建立独立的索引，并不会带来过多的优化，sql语句中包含多个and筛选，这多列做成一个索引优于建立多个独立索引；如果是or的状况的话，一般直接扫描全表来的更快一点；多列索引对关键字的顺序要求比较高，把选择性更高的关键字放在第一个位置会加快查询效率 要避免多个范围查询，对这些范围所在的列做索引并没达到预期的目的，mysql并不支持利用索引来进行多个范围的查询，例如select user.* from user where login_time &gt; &#39;2017-04-01&#39; and age between 18 and 30; 如果要查询的值都在索引列中，那么使用覆盖索引效率会更高；索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量；索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多 对于大多数情况，扩展索引优于创建新索引 删除长期未使用的索引 特定类型优化count(*) 如果不需要准确值，那么直接explain命令得到近似值也可以 统计行数，使用count(*)意义更清晰 union查询 都是把数据全部存入临时表，然后再从临时表读取数据，返回客户端 all关键字如果不加，默认是distinct，会增加消耗 更方便的做法是直接返回子查询的结果 limit 如果间隔量太大，使用覆盖索引来做会优化更高 SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;替换成(使用title做索引)：1234567SELECT film.film_id,film.descriptionFROM film INNER JOIN ( SELECT film_id FROM film ORDER BY title LIMIT 50,5) AS tmp USING(film_id); 详细资料]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式，类特殊方法笔记]]></title>
    <url>%2F2018%2F08%2F13%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[元类，特殊类方法元类 中断类的默认创建、修改类、最后返回修改后的类. python中一切都是对象，类也是对象，类本身可以算是元类的实例 type(class_name, (father_class_name), {key:value}) 使用class能判断当前对象对应的类 12345In [6]: "11".__class__Out[6]: strIn [7]: "11".__class__.__class__Out[7]: type 在定义一个类的时候，对metaclass进行定义，那么该类就会按照metaclass来设计类 寻找元类的机制12class Foo(bar): pass Foo中有metaclass这个属性吗？ 如果有，python会在内存中通过metaclass创建一个名字为Foo的类对象。 如果python没有在Foo中找到metaclass，它会继续在Bar（父类）中寻找metaclass，并尝试做和前面同样的操作。 如果python由下往上遍历父类也都没有找不到metaclass，它就会在模块(module)中去寻找metaclass，并尝试做同样的操作。 如果还是没有找不到metaclass， python才会用内置的type(这也是一个metaclass)来创建这个类对象。 123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, attrs): uppercase_attr = &#123;&#125; for name, val in attrs.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, attrs) # 等价1 return type.__new__(upperattr_metaclass,future_class_name，future_class_parents, uppercase_attr) # 等价2 return type(UpperAttrMetaclass, future_class_parents, uppercase_attr) super 在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了，可通过使用 super 来实现 一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则： 子类永远在父类前面 如果有多个父类，会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 123def super(cls, inst): mro = inst.__class__.mro() return mro[mro.index(cls) + 1] 其中，cls 代表类，inst 代表实例，上面的代码做了两件事： 获取 inst 的 MRO 列表 查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1] 当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。 new和call new(cls, […])在创造实例前，定义完类就保存该类对象到内存中 call(self, […])在调用实例的时候，一般用来改变实例的某些属性 单例模式 该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。 使用模块，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码 使用 new 12345678 class Singleton(object): _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 使用装饰器（decorator） 12345678910111213from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass(object): a = 1 使用元类（metaclass） 123456789101112class Singleton(type):_instances = &#123;&#125;def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls]# Python2class MyClass(object): __metaclass__ = Singleton# Python3# class MyClass(metaclass=Singleton):# pass 详细阅读1详细阅读2详细阅读3]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F2018%2F08%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络协议传输层的网络协议(tcp， udp)TCP连接 TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 三次握手 客户端发起连接请求，自身变为SYN_SEND的状态 服务端接收到请求，发起确认连接的请求，自身SYN_RCVD状态 客户端发送确认包，服务端接收到，两个的状态都变成ESTABLISHED状态，握手结束 四次挥手 客户端发起请求，自身进入wait的状态 服务端接收到请求，自身进入close_wait的状态，告诉客户端，还没准备好，等一会 服务端再次发送请求，进入LAST_ACK状态 客户端接收到关闭请求，发送确认包，自己进入time_wait的状态。 服务端接收到确认包后，关闭连接；客户端等待一段时间后，没有收到服务端的ack包，关闭自己的连接 keep alive TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 UDP连接 缺乏可靠性，只管发，不管客户端收到还是没有收到 UDP是无连接状态的，发送数据不要经过创建连接的过程 广播和多播支持 网络层IP协议 为数据包选择路由 IP实现两个基本功能：寻址和分段 IP的责任就是把数据从源传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务。 应用层的HTTP协议 建立tcp连接 客户端向服务端发送请求 客户端发送请求头信息，客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送 服务器应答，响应的第一部分是协议的版本号和响应状态码 服务器返回响应头信息 服务器向客户端发送数据 服务器关闭 TCP 连接，如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 常用状态码解析 200 表示从客户端发来的请求在服务器端被正常处理了。 204 No Content， 一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用 301 Moved Permanently，永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存 302 临时性重定向。表示请求的资源已被分配了新的 UR 400 Bad Request，表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 401 Unauthorized，表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息 403 Forbidden， 明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述 404 Not Found， 表明服务器上无法找到请求的资源。 500 nternal Server Error，表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。 503 Service Unavailable，表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。 大致流程图]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F2018%2F08%2F07%2F8%E7%AE%97%E6%B3%95%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见排序算法插入排序 原理：类似于在排序的时候，创建一个新数组，新数组中是已经排好序的数组，然后从老数组中依次取值，拿出的值在新数组中依次比较，找到自己的位置，然后再从老数组中取新，重复上述办法 123456789101112def insert_sort(lists): # 插入排序 count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists 希尔算法 原理： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序 然后取 d2(d2 &lt; d1) 重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。 12345678910111213141516171819def shell_sort(lists): # 希尔排序 count = len(lists) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group /= step return lists 冒泡排序 原理： 遍历数组，每次都拿一个值和剩下的所有值比较，判断是否交换位置。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 12345678910def bubble_sort(lists): # 冒泡排序 count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: temp = lists[j] lists[j] = lists[i] lists[i] = temp return lists 快速排序 原理： 取老数组的第一个数，将比他大的放左边，比他小的放右边，然后分别对左右两边的数组进行递归操作 i =L; j = R; 将基准数挖出形成第一个坑a[i]。 j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 123456789101112131415161718def quick_sort(lists, left, right): # 快速排序 if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 直接选择排序 原理： 每次都查找剩下数组里面最小的元素到循环次数的位置，例如第0次循环，就找老数组最小的数，放到索引0的位置，下一次找剩下的数组中最小的元素放到索引1的位置，依次类推 123456789101112def select_sort(lists): # 选择排序 count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j temp = lists[min] lists[min] = lists[i] lists[i] = temp return lists]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器相关知识]]></title>
    <url>%2F2018%2F08%2F07%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[装饰器相关知识 装饰器是一个可以调用的对象，接收的参数是一个函数，装饰器可以改变被装饰的函数，然后返回原函数或者其他可以调用的对象 将函数替换成另外的函数12345678910def deco(func): def test2(): print('hello, world')return test2@decodef test1(): print("I'm the world!") //result: hello, world 特性 能把被装饰的函数替换成其他函数。 装饰器在加载模块时立即执行 例如在导入一个py文件时，文件中包含有装饰器以及被装饰的函数，那么导入后，会发现实际上装饰器已经执行了封装的效果，引入的函数是已经装饰过的 变量作用域 一般来说，函数体中的变量优先在函数体内寻找，如果找不到那么才从全局作用域寻找， 但要注意+=的使用，使用该运算符的前提是变量已经定义。 并且，如果在打印输出的后有定义该变量，那么执行依然会报错 1234567y = 7def f1(x): print(x) print(y) y = 3// 报错，print(y)会报错y未定义 global可以使用该参数，定义全局变量 闭包 对一个函数进行了延伸，可以使用被装饰函数外的非全局变量 1234567// 计算动态平均值def make_averager(): series = [] //必须是可变对象 def averager(new_value): series.append(new_value) total = sum(series) return total/len(series)return averager series是make_averager函数的局部变量，返回后该局域变量域就已经结束了 对averager函数而言，series是一个自由变量(指未在本地作用域中绑定的变量) 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定， 这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定 只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量 注意 自由变量必须是一个可变的对象，否则在被装饰函数体内使用该变量会报错未定义 12345678910111213def make_averager(): count = 0 total = 0 def averager(new_value): count += 1 total += new_value return total / countreturn averager// 报错，count未定义，因为在averager函数体内部，未count赋值了，那么会将count变成局部变量，total变量也是一样 python3中有关键字nonlocal，可以保存在闭包中使用的变量 functools模块中常用装饰器functools.wraps 该装饰器可以将被装饰的函数属性复制到装饰函数中，常用来恢复被装饰函数修改过的name和doc属性 1234567891011121314151617181920import time import functoolsdef clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.time() result = func(*args, **kwargs) elapsed = time.time() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[%0.8fs] %s(%s) -&gt; %r ' % (elapsed, name, arg_str, result)) return result return clocked functools.lu_cache 主要用来缓存，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU 三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存 条目会被扔掉。 functools.singleddispatch 将一个装饰器扩展成多个来使用，可以在系统的任何地方和 任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可 以轻松地添加一个新的专门函数来处理那个类型。此外，你还可以为不 是自己编写的或者不能修改的类添加自定义函数 123456789101112131415161718192021222324252627from functools import singledispatch from collections import abc import numbers import html@singledispatchdef htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content)@htmlize.register(str)def _(text): ➌ content = html.escape(text).replace('\n', '&lt;br&gt;\n') return '&lt;p&gt;&#123;0&#125;&lt;/p&gt;'.format(content)@htmlize.register(numbers.Integral)def _(n): return '&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'.format(n)@htmlize.register(tuple) @htmlize.register(abc.MutableSequence) def _(seq): inner = '&lt;/li&gt;\n&lt;li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\n&lt;li&gt;' + inner + '&lt;/li&gt;\n&lt;/ul&gt;' 参数化装饰器 创建一个装饰器 工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰 的函数上。 123456789101112131415161718192021registry = set()def register(active=True): def decorate(func): print('running register(active=%s)-&gt;decorate(%s)' % (active, func)) if active: registry.add(func) else: registry.discard(func) return func return decorate@register(active=False)def f1(): print('running f1()')@register() def f2(): print('running f2()')def f3(): print('running f3()')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[devops文化和SRE的职责]]></title>
    <url>%2F2018%2F08%2F07%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2Fdevops%E6%96%87%E5%8C%96%E5%92%8CSRE%E7%9A%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[devops的各种理解维度 业务，架构以及技术 人，流程和工具 原则，方法和实践 微服务是否上线 业务都可以从一个单例应用开始，不着急上微服务 但应该打好基础，时刻做好扩展的准备 架构如此重要，所以一旦业务相对清晰一些，就要根据业务需要，考虑逐渐切换到微服务架构，才不至于堆积太多技术债务，对于可扩展性、可规模化、可部署性等也都至关重要 团队效率永远都是高于个人效率，能统一技术栈对后续的扩展，优化，减少了更多不必要的工作 最新的未必是最合适的，永远追逐最新的技术，往往丧失了自我的思考和技术的积累。 工具是次要的，人才是最重要的 只有正确执行了devops的步骤，那么不管使用什么工具都是可以的 svn公司对ci的定义 只维护一条主线代码 自动编译代码 自动测试 每个人每天的代码都合并到主线 每个提交都需要在集成环境中重新编译主线代码 编译过程中出现的任何问题，都需要立即开始解决 保持快速的编译 在一个和生产环境完全相同的环境下测试代码 每个人都能非常方便的知道最新的编译结果 每个人都知道这过程中发生了什么 自动部署 devops和sre的关系 两者都是面向数据的，都对SLOs(服务质量目标)决定着是否改善优化服务 都针对持续小而频繁的变更，每次的变更都需要自动化测试和应用 sre所针对的方向更小，更看重从用户的角度出发而不是整个系统 devops更像是一个宽泛的文化，更重要的是优化开发和运维中间层 参考资料 参考资料]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量修改git的配置邮箱和名字]]></title>
    <url>%2F2018%2F08%2F04%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E7%9A%84%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E5%92%8C%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[设置当前电脑环境的git配置12git config --global user.email xxxxgit config --global user.name xxx 如果不加global参数，只对当前的git库有效，当前.git目录下有config文件可以看到 全局配置文件在home目录下的.gitconfig中 需要对某个git库批量修改12git filter-branch --env-filter 'export GIT_AUTHOR_EMAIL=new_author_email' --git filter-branch --env-filter 'export GIT_AUTHOR_NAME=new_author' -- 每次执行完一条语句，可以直接push -f，就可以全面修改远程git库中的信息 再执行另外一条语句时，因为本地.git/refs/origin目录已经存在，要么删除掉该目录，要么执行新的修改命令需要加-f参数]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的对象引用和垃圾回收]]></title>
    <url>%2F2018%2F07%2F29%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[python中的对象引用和垃圾回收 每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标识的整数表示。可以把创建变量看作是贴标签，创建对象之后才会把变量分配给对象 ==和is的区别 ==比较的是两个对象的值，is比较的是两个对象在内存中的标识(内存地址)是否相同 is一般用来判断None对象 而 a == b 是语法糖，等同于 a.eq(b)。继承自 object 的 __eq__方法比较两个对象的 ID 默认都是浅拷贝 深复制（即副本不共享内部对 象的引用） 简单的赋值不创建副本 构造方法l2 = list(l1)或 [:] 做的是浅复制，修改其中一个对象值，不会影响另外的一个 对可变的对象来说，+= 运算符就地修改列表 对元组来说，+= 运算符创建一个新元组，然后重新绑定给变量 del del一个对象，只是删除对它的引用，只有当删除的时候是最后一个引用的时候，才会从内存中删除该对象地址 如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序 会判定它们都无法获取，进而把它们都销毁。 垃圾回收 在 CPython 中，垃圾回收使用的主要算法是引用计数。实际上，每个对 象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销 毁：CPython 会在对象上调用 __del__方法（如果定义了），然后释放 分配给对象的内存。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jinja2的语法结构]]></title>
    <url>%2F2018%2F07%2F26%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fjinja2%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[jinja2的语法结构分隔符1234- &#123;%...%&#125;语句基本结构- &#123;&#123;...&#125;&#125;打印模板的输出，大括号和里面的值都要保持一个空格- &#123;#...#&#125;注释- #...##行语句，用来注释用 12345&#123;# note: 多行注释 &#123;% for user in users %&#125; ... &#123;% endfor %&#125;#&#125; 变量 支持字符串变量，列表、字典和对象 1234567&#123;&#123; mydict['key'] &#125;&#125;&#123;&#123; mylist[3] &#125;&#125;&#123;&#123; mylist[myintvar] &#125;&#125;&#123;&#123; myobj.somemethod() &#125;&#125;# 以下等效&#123;&#123; foo.bar &#125;&#125;&#123;&#123; foo['bar'] &#125;&#125; 过滤器 safe 渲染时不转义 capitalize 首字母大写 lower 小写 upper 大写 title 每个单词的首字母都转换成大写 trim 去掉首尾空格 striptags 去掉值里的HTML标签 default 设置一个默认值，如果变量未定义，就用这个默认值替换，my_variable is not defined 判断语句 tests可以用来在语句里对变量或表达式进行测试，如果要测试一个变量，可以在变量后加上“is”和test名 123&#123;% if user.age is equalto 42 %&#125; &#123;# 这里也可以写成... is equalto(42) #&#125; Ha, you are 42!&#123;% endif %&#125; 常用的test defined equalto escaped none sequence string number reverse replace 循环取值 在for循环内，以下特殊变量可以直接使用 loop.index 当前迭代数，可以用来写评论的楼层数（从1开始） loop.index0 同上，不过从0开始迭代 loop.revindex 反向的迭代数（基数为1） loop.revindex0 反向的迭代数（基数为0） loop.length 序列的数量 loop.first 是否是第一个元素 loop.last 是否是最后一个元素 空格控制 默认情况下，末尾如果有换行符，直接去除 其他空格都原样保留 12345&lt;div&gt; &#123;% if True %&#125; yay &#123;% endif %&#125;&lt;/div&gt; 效果如下：12345&lt;div&gt; yay&lt;/div&gt; 注意：Jinja2语句占据的空行，你自己输出的空格，Tab都将保留。如果需要删除，有两种方法来实现 设置jinja2的环境变量 12app.jinja_env.trim_blocks = Trueapp.jinja_env.lstrip_blocks = True 手动添加一个减号(和%号之间没有空格) 12345&lt;div&gt; &#123;% if True -%&#125; yay &#123;%- endif %&#125;&lt;/div&gt; 效果如下： 123&lt;div&gt; yay&lt;/div&gt; 如果要删除全部的空格 12345&lt;div&gt; &#123;%- if True -%&#125; yay &#123;%- endif -%&#125;&lt;/div&gt; 效果如下： 1&lt;div&gt;yay&lt;/div&gt; 转义 小块内容直接用‘’来包裹，{{ 大块内容使用raw代码块 1234567 &#123;% raw %&#125; &lt;ul&gt; &#123;% for item in seq %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% endraw %&#125; 模板继承 一般情况下为了重复利用某些代码，创建一个base.html作为基模板，把导航栏、页脚、flash消息、js或css文件等等需要在每一个页面中显示的内容放在基模板里，并添加一个空的块用来放置其他子模板的内容：block content %&#125;&#123;% endblock %&#125;```1234567&gt; 在其他的模板（子模板）里使用这个extends语句继承它，并放置相应的内容到基模板里定义过的空块：&gt; ```python&gt; &#123;% extends &quot;base.html&quot; %&#125; &#123;% block content %&#125; 子模板的内容 &#123;% endblock %&#125;&gt; 如果想添加内容到在父模板内已经定义的块，可以使用super函数：1234567 &#123;% block sidebar %&#125; &lt;h3&gt;Table Of Contents&lt;/h3&gt; ... &#123;&#123; super() &#125;&#125; &#123;% endblock %&#125; 这样可以避免覆盖父块的内容。&gt; 详细信息]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dayone cli的使用]]></title>
    <url>%2F2018%2F07%2F23%2F4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2Fdayone%E5%AF%B9cli%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[dayone cli的使用 dayone2 的mac端提供了一个客户端脚本，可以直接运行下面的命令来安装 sudo /Applications/Day\ One.app/Contents/Resources/install_cli.sh 安装完后，可以直接使用dayone new xx 来测试，实际上就是把xx当作文本传入dayone应用执行，生成新的日记 使用vim来写入文本，讲文本记到dayone中 生成一个模板，脚本里面会直接赋值一份新的今天的文本供修改，然后生成新日记后删除新的文本]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT和session的区别]]></title>
    <url>%2F2018%2F07%2F23%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fjwt%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[JWT和session的区别 这两种数据结构存储方式主要都是用来保存用户的一些信息，常见的是登录信息 session的存储 当 client通过用户名密码请求server并通过身份认证后，server就会生成身份认证相关的 session 数据，并且保存在内存或者内存数据库。并将对应的 sesssion_id返回给client，client会把保存session_id（可以加密）在cookie。此后client的所有请求都会附带该session_id，以确定server是否存在对应的session数据以及检验登录状态以及拥有什么权限，如果通过校验就该干嘛干嘛，否则重新登录。前端退出的话就清cookie。后端强制前端重新认证的话就清或者修改session 优势 和JWT对比，session能主动清除 session的完整数据保存在服务器端，安全性更优保障 和cookie联合使用(session返回id给cookie存储在客户端)，灵活，兼容性更高 劣势 在跨域的情况下，使用session会很麻烦(可以多机器共享session，例如可以将session存储进数据库或者reids中) 基于cookie的机制容易被CSRF(模拟用户在客户端的数据来向server端发送请求) 查询session需要数据库方面的查询操作 JWT的存储方式 JSON Web Token 定义了一种由.分隔的数据结构，由三部分组成，分别是header，Payroad,Signature,完整结构Header.Payload.Signature 字符串中每一段都是被 base64url 编码后的 JSON，其中 Payload 段可能被加密 header JWT 的 Header 通常包含两个字段，分别是：typ(type) 和 alg(algorithm) typ：token的类型，这里固定为 JWT alg：使用的 hash 算法，例如：HMAC SHA256 或者 RSA 1234&#123; "alg": "HS256", "typ": "JWT" &#125; payroad 真实存储我们需要传递的信息的部分，例如正常我们会存储些用户 ID、用户名之类的。此外，还包含一些例如发布人、过期日期等的元数据 一般使用Base64UrlEncoder进行加密数据 signature 对header和payroad部分加密，保证token传输过程中没有没篡改 除了 Header 和 Payload 之外，还多了一个密钥字段 1Signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 工作方式 前端发起post请求，发送用户名和密码到server 后端核对成功，组装用户id等数据到payroad，加密header和payroad后签名，返回给前端 前端保存JWT数据到localStorage或sessionStorage，退出登录删除该数据 每次请求将jwt放在HTTP请求的HEADER-Authorization中，防止xss和xsrf攻击 后端验证JWT数据，返回结果 优势 扩展性更强 随着应用程序的扩大和用户数量的增加，你必将开始水平或垂直扩展。session数据通过文件或数据库存储在服务器的内存中。在水平扩展方案中，你必须开始复制服务器数据，你必须创建一个独立的中央session存储系统 用JWT是无缝的;由于基于token的身份验证是无状态的，所以不需要在session中存储用户信息。我们的应用程序可以轻松扩展，因为我们可以使用token从不同的服务器访问资源，而不用担心用户是否真的登录到某台服务器上。你也可以节省成本，因为你不需要专门的服务器来存储session 安全性更高 JWT签名旨在防止在客户端被篡改，但也可以对其进行加密，以确保token携带的claim 非常安全 下游的服务 现代web应用程序的另一种常见模式是，它们通常依赖于下游服务。例如，在原始请求被解析之前，对主应用服务器的调用可能会向下游服务器发出请求。这里的问题是，cookie不能很方便地流到下游服务器，也不能告诉这些服务器关于用户的身份验证状态。由于每个服务器都有自己的cookie方案，所以阻力很大，并且连接它们也是困难的 对restful api的架构表现更好 RESTful API的原则之一是它应该是无状态的，这意味着当发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。保持API无状态，不产生附加影响，意味着维护和调试变得更加容易 由一个服务器提供API，而实际应用程序从另一个服务器调用它的模式是很常见的。为了实现这一点，我们需要启用跨域资源共享（CORS）。Cookie只能用于其发起的域，相对于应用程序，对不同域的API来说，帮助不大。在这种情况下使用JWT进行身份验证可以确保RESTful API是无状态的，你也不用担心API或应用程序由谁提供服务 劣势 性能差 当从客户端向服务器发出请求时，如果大量数据在JWT内进行编码，则每个HTTP请求都会产生大量的开销。然而，在会话中，只有少量的开销，因为SESSION ID实际上非常小 时效性差 无状态JWT的实效性相比session太差，只有等到过期才可销毁，而session则可手动销毁 用户发现账号被异地登录，然后修改密码，此时token还未过期，异地的账号一样可以进行操作包括修改密码 将JWT生成的token存入到redis或者数据库中，当用户登出或作出其他想要让token失效的举动，可通过删除token在数据库或者redis里面的对应关系来解决这个问题。 session、cookie、sessionStorage、localstorage的区别 session: 主要存放在服务器端，相对安全 cookie: 可设置有效时间，默认是关闭浏览器后失效，主要存放在客户端，并且不是很安全，可存储大小约为4kb sessionStorage: 仅在当前会话下有效，关闭页面或浏览器后被清除 localstorage: 除非被清除，否则永久保存]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软技能]]></title>
    <url>%2F2018%2F07%2F22%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E8%BD%AF%E6%8A%80%E8%83%BD-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[软技能-读书笔记 一门给程序员解答除了技术上的提高，对职业生涯，甚至以后的生活都有所影响的书籍。改变了程序员一些固有的概念，对自己的生活，职业，甚至人际关系都有很好的指导 职业把自己当作一件企业 技能，性格等因素都关系到公司正常的运行，以后公司发展壮大还是失败(下岗)，跟自己都是息息相关的 专注于你正在提供怎样的服务，以及如何营销这项服务； 想方设法提升你的服务； 思考你可以专注为哪一特定类型的客户或行业提供特定的服务； 集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务（记住，作为一个软件开发人员，你只有真正 专注于一类客户，才能找到非常好的工作）。 时刻专注你的职业生涯，你的长远目标是为了实现什么 设定一个长远的目标，将之拆分成一个个小的目标，那么在渐渐努力靠近大目标的路上，你才不会迷失方向，并且一个个小目标的实现，有助于提高兴奋度和成就感 为职业生涯设定一个大目标 拆分大目标为一个个的时间节点，例如在就职的每家公司都学到了什么，有什么不足，这样在后面的求职上才有一个明确的方向，不要为了一份工作而草率的去工作 大的时间节点又可以拆分为年，月，周，甚至每天都有一个小目标，并定期审核这些目标能否帮助自己靠近自己设定的大目标 人际交往 人际交往是程序员进入公司后最容易忽略掉的一个，甚至有些人会排斥。他们更擅长与机器打交道，而不是和人打交道。但实际上，你从事的工作就是为人服务的，不管是写软件还是管理，通通都是为人服务，所以不要厌烦，而是应该主动去接收它 每个人都希望地球是围着自己转的，因此，和人打交道，不要轻率否决别人的想法，而是将自己带入别人，再给出建议，注意，仅仅是建议，而不是决定 永远不要批评，奖励积极行为永远比惩罚消极要有效得多，鼓励才是鼓舞士气最好的方式 换位思考，停止用“我”和“我想要什么”来思考。你应当开始思考对他人而言什么才最重要，什 么才是他们需要的。尤其是做产品的时候，自己盲目的以为用户需要，实际上做出来的东西，用户并不认同，这就是根本的原因 避免争吵，在小事情上，任何放弃立场或承认错误的机会对你而言可能没什么大不了的，但对他人却可能是举 足轻重的，这么做不仅能为你赢得不可估量的尊重，也能为你的未来积蓄财富，形势逆转时即可兑现使用 面试 所有的工作都需要面试，除非你是老板。能提前和面试公司的员工打好关系，甚至能和面试官有一定的交流，让他充分了解到你这个人，那么对后面的面试是相当大的帮助 让自己出名，能有一个地方展示自己，例如博客等 突破常规，想尽办法与公司内部人员建立联系，让内部人帮你推荐，那么就相当于已经有人利用自己的公信力为你背书 在技术上你能胜任，但相较于其他面试者，你占用的资源更少(时间，管理成本等) 实践，就算是为了面试经验，也应该经常出去面试，一方面是了解市场，另一方面是增加自己的面试经验 就业的选择 主要就是在为别人打工，为自己打工当中作出一个选择 雇员，合同制员工，大部分的选择。比较稳定，有各种福利，假期等，但同样的，薪资有天花板，并且作息时间固定 自由职业者，自己就是商品，为自己打工。比较自由，赚的钱都是自己的，有潜力，能按照自己的喜好来工作。但需要自己出去推销自己，项目也不太稳定，为一个人服务变成为多人服务 创业，这是完完整整的自己给自己打工，赚钱的潜力巨大，并且没有老板，你自己开发自己想做出来的东西；但相应的风险也是最大的，完全都只能靠自己，需要涉及到各种不同专业的技能，并且要长时间的工作刚开始，都是从雇员做起，慢慢发展到为自己服务的阶段，也就是财务自由后的选择 定义自己 需要为自己做一个完整的评估，不管你是从事具体哪门语言的，你应该更深入挖掘自己，例如会python，名头是python开发工程师，但实际上从事的是运维开发这一块的工作，更往小里说，是专业从事自动化运维方向，开发工具的人员。 专业化很重要。只有专精于具体某一项，不管是找工作，还是以后的职业发展，才会有一个明确的目标，不要以为专精于一项，找工作很小众，但实际上，公司对于这一块小众的方向更愿意拿出价钱来 一些开发人员的专业化水平确实很深，已经成为某个具体平台或框架的专家。这些开发人员的潜在客户稀少，但由于他们 的专业化水平，他们能够开出非常高的时薪。 学富五车，或者灵活变通并同时仍有所专长让自己卓尔不群。如果你非要二选一，那先从专业化开始，再拓展分支 公司的选择 小公司，小公司一般都是创业公司，为了盈利，可能会加班加点，并且需要一个人干几个人的活，需要的知识面比较广，并且不愿意培养人 中等公司，有盈利的业务，比较稳定，但往上提升的空间有限，在中等规模的公司里，缓慢而稳健的做事风格通常能占得先机 大公司，最大的事情也许就是那里大量的规范和流程，并且大公司愿意培养人才，培训的机会很多，对出入职场的人很有帮助。大公司通常有着复杂的政治体制，你想要完全置身事外，那最好栖身于 扁平化管理结构的小公司。 如果有选择在软件行业的公司和非软件行业，那么尽量选择软件行业的人，这样公司都是这样的人，工作环境会更让你感觉到舒服。 如何获得晋升 获得晋升，包含了提职，加薪等内容，每个人都想得到晋升的机会，但要获得晋升，必然要让别人看到你的价值所在 勇于承担责任，在任何公司里能让你脱颖而出的最重要法宝就是承担更多的责任。牵头项目，或者新人的导师，这两方面都很容易得到机会 引人注目，例如每天写日报，周报；参加演讲，培训别人；在会议上能有自己的独特建议；保证在领导面前的曝光度 自学，自学是最廉价，最有效的获得自身技能提升的方式。不要只学软件开发，管理，营销等方面都可以学习 称为解决问题的专家 远离办公室政治 努力称为专业人士 引人注目，恪尽职守，以及不屈服于挫折。成为专业人士，需要你克服自身的缺点，静下心来 创作出尽可能最好的作品。 严肃对待自己的责任和事业，敢于说不 养成良好的习惯，最成功的人士都很自律 坚守正道，专业人士会评估需要完成的工作，判定优先级后再 开始工作。 追求品质，完善自身的能力 如何辞职 不要在自己缺乏坚实的计划之前就决定辞职，在考虑辞掉工作之前，你需要有一个切实可行的计划。我强烈推荐先在业余时间启动你想创建的业务，等能从这项业务中 产生足以维持生计的收入时，你再转为全职 在准备好自己全职为自己工作之前，先对自己进行测试，能否适应这样的工作状态 注意签合同时，有些公司会表明，员工所有的劳动成果都属于公司，那么你再业余时间内的产出也会算到公司头上 成为自由职业者 从做兼职开始，因为你需要一个长久的客户来避免你陷入财政危机 从周围人中获得经验，如果有人已经开始了自由职业者的阶段 获得客户最佳途径的就是你的亲人和朋友，所以你需要推销自己出去，先从免费的做一些有益于别人的事情开始，然后后续就会得到关注，这样才能有真正的客户关注到你 你可以把自己的工作看作是商品，也可以把它看作是能够增加客户盈利能力的服务。如果你决定把自 己的工作看作是商品，为了工作你就不得不跟其他开发人员竞价了，这些人中很多人的出价是很低的 如果没有任何潜在客户跟你讲“不行”或者“你的收费太贵了”，马上提高费率！不断给你的收费加码， 直到你听到“不行”为止。客户愿意为你的服务付的价格可能会让你大吃一惊。 开发你的第一个产品 为自己的产品寻找定位，首先应该找准一个方向，然后再从论坛，社区等该方向的客户询问他们的痛点，根据这些再来开发，避免先自己天马行空的认为产品应该是什么样子就直接执行了，这样不利于后期的推销 测试市场，产品推出之前可以先问下受众并且愿意付费的用户有多少，再开始执行，这样能让你更有安全感的开发 从小处着手，尽可能缩短自己的学习曲线，尽量缩短开始行动到看到成果之间的周期，这也是为什么创业公司都会加班加点的干活来抢占市场 开始远比空想更有意义 远程工作的策略 时间管理，日程表越有规律、越是规划得当越好 自我激励，可以从设定一个15分钟的全身心投入来实施，事实证明，一旦我们专心致志地工作一段时间，我们就会沉 浸其中，也有动力继续。我把这称为冲量效应 孤独感，需要时常与其他人交流，保证信息的畅通的同时，也能避免自己产生的孤独感 改善简历 简历是雇佣者了解你的唯一选项，如果你不是很出名的话 保持自己的简历在线 雇佣专门修改简历的优化你的简历 对自己的简历保持严谨的态度，不要让你们多出错别字，或者不明确的东西 不要一个劲的只投入到技术中 技术很重要，但有些东西并不代表全部 长时间从事同一个方向的技术，不要贬低其他的种类，你了解了也许会有和之前截然相反的想法 在很多情况下，解决问题并不只有一个好的或是最好的方法。同理，最好的编程语言、 框架、操作系统，甚至是文本编辑器不会只有一种 对技术保持开放的心态]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的multiprocessing模块使用]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fmultiprocessing%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[multiprocessing模块 pool的内置方法apply_async（）方法中，传入给方法的参数中，不允许有实例对象，只能将类传入进去，在子进程中实例化]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible简单使用]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fansible%2F</url>
    <content type="text"><![CDATA[ansible ansible-vault 用来打开加密的数据(create, edit) ansible -m xxx(module name) 123ansible -m ping 192.168.95.25 -i hosts --ask-vault-pass# hosts 加密文件# 后面的命令是解密的密码]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 的多版本管理工具]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fmac%E4%B8%8A%E5%AF%B9%20python%20%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[mac上对 python 的多版本管理工具anaconda 所有的命令执行都是 conda常用命令 conda update conda 升级 anaconda conda version 查看 anaconda 的版本 conda info --envs 查看当前安装的 python 版本 创建 python 的虚拟环境 conda create --name xxx yyy xxx代表环境的名字, yyy 表示 python 的包,整个命令的意思就是创建一个 yyy 包的 xxx 名字的虚拟环境 conda create -n xxx2 python=3 yyy1 yyy2 创建一个 python3版本的 yyy1,yyy2的虚拟环境 可以不接包的名字 切换不同版本的 python source activate xxx xxx 代表具体的虚拟环境名字 source deactivate 取消虚拟环境,使用系统自带的环境 删除环境 conda remove -n xxx --all 删除该虚拟环境下的所有东西 管理具体的 python 包 conda list 查看当前环境下的包版本等信息 conda search xxx 查找某一个包 conda install -n xx yy 为 xx 的环境安装 yy 的包,不设置该参数,安装到当前环境下 conda remove -n xxx yy 为 xxx 的环境删除 yy 的 python 包,删除所有使用参数 –all 删除 anaconda rm -rf ~/miniconda OR rm -rf ~/anaconda]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码的问题]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2F%E7%BC%96%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[编码的问题 \x 表示的是utf8的编码格式，想要转成中文字符的话，可以将\x换成%，然后复制到浏览器上面，就能清晰的看到了 \u 表示的unicode编码的字符串，python里面直接print u’xxx’就可以看到具体信息了]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE框架]]></title>
    <url>%2F2018%2F05%2F31%2F5%E5%89%8D%E7%AB%AF%2Fvue%2FVUE%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[VUE框架升级vue版本 npm install xxx --save // xxx 代表vue等包，全局安装或升级单独应用的更新，需要进入到具体目录，然后npm update xxx vue的watch方法，具体的方法变量又发生变化的时候才开始执行 主要是checkbox的全局效果有影响，必须在beforemount的方法的时候，判断下顺序，因为具体方法的执行不是异步的 v-bind:value 与 v-model的区别 v-bind是单向绑定，在select框中，默认是将值绑定到select选项里面 v-model是双向绑定，切换会影响到其他地方 注意： 在select框中，一般是在select层套一个v-model，具体的值用template以及v-for来展示]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite简单使用]]></title>
    <url>%2F2018%2F05%2F31%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fsqlite%2F</url>
    <content type="text"><![CDATA[sqlite 一个轻量级的数据库,平时写的一些小程序实际上用 sqlite 就能解决了 安装 osx 上面的安装直接使用 brew install sqlite 就可以安装完成了 常用命令 基本上常见的命令都是以.开头的 .help 查看常见命令 .databases 查看当前目录下的所有数据库 .dump 导出当前数据库的数据 sqlite3 testdb.db .dump &gt;a.sql 导出sqllite3 testdb.db &lt;a.sql 导入 sqlite3 testdb.db 创建数据库 attach database &#39;databasename&#39; as &#39;aliasname&#39; 新增一个数据库,并另命别名为 xxx detach database &#39;alias-name&#39; 给某个数据库换一个别名 创建表与 mysql 一样,字段也差不多 其余语句均和 mysql 差不多,不管是 select,where,or,and,distinct,like 等都可以使用 NULL 值是一个 NULL 值。 INTEGER 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中 REAL 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。 TEXT 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储. BLOB 值是一个 blob 数据，完全根据它的输入存储。 注意实际上 varchar 类型都是可以的,会自动判别为 text, 详细信息请查看 详情 重要的是时间节点, sqlite 默认是使用 GMT 的时间,也就是格林尼治时间,不然当前时区,如果要使用当前时区的时间,那么需要使用localtime,命令如下select datetime(current_timestamp, &#39;localtime&#39;); limit 和 offset 的使用 limit的意义在于只保留多少条数据 offset 的意义是跳过多少条数据 两个命令结合起来就可以组合成一个只保留最新多少条数据的复合语句 12delete from smzdm where id in (select id from smzdm order by id desc limit (select count(*) from smzdm) offset 40) and user_id=1; 删除 table 里面的某一列 不支持 alter drop 的操作,只能重新删除表,再次建一个]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的转化字符串为html格式]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%20%E5%B0%86%E5%AD%97%E5%85%B8%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%88%90html%20%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python 将字典的特殊字符转换成html 编码 urllib.quote 123456789In [16]: urllib.quote(json.dumps(a))Out[16]: '%7B%22project%22%3A%20%22test%22%2C%20%22messge%22%3A%20%22mysql%20qps%20%3E300000%20is%20down%22%2C%20%22hostname%22%3A%20%22salve-02%22%2C%20%22alert_time%22%3A%20%222017.06.07%2014%3A17%3A25%22%2C%20%22value%22%3A%20%22500%22%7D'In [17]: aOut[17]:&#123;'alert_time': '2017.06.07 14:17:25', 'hostname': 'salve-02', 'messge': 'mysql qps &gt;300000 is down', 'project': 'test', 'value': '500'&#125; urllib.encode 只是将字典的键值对取出来作为url的参数和值的形式 12In [18]: urllib.urlencode(a)Out[18]: 'project=test&amp;messge=mysql+qps+%3E300000+is+down&amp;hostname=salve-02&amp;alert_time=2017.06.07+14%3A17%3A25&amp;value=500' python中数据结构中包含有unicode编码的字符串 可以使用json.dumps 1234567891011In [16]: a=&#123;'1': u'你好'&#125;In [17]: print a&#123;'1': u'\u4f60\u597d'&#125;In [18]: import jsonIn [19]: print json.dumps(a, indent=4)&#123; "1": "\u4f60\u597d"&#125; 对list的类型，可以使用join方法 123456789101112In [20]: a = [u'a', u'b', u'c']In [21]: print a[u'a', u'b', u'c']In [22]: ",".join(a)Out[22]: u'a,b,c'In [23]: c = ",".join(a)In [24]: print ca,b,c 单个字符串可以直接用replace替换]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的类方法]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%20%E7%B1%BB%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python 类内置方法repr 和 str 的比较 从上图可以看出,两个方法都是倾向于字符串的处理repr和str这两个方法都是用于显示的，str是面向用户的，而repr面向程序员。 打印操作会首先尝试str和str内置函数(print运行的内部等价形式)，它通常应该返回一个友好的显示。 repr用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用str，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。 实例—一个类似字典的映射对象123456789101112131415161718class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): print(key,value) self.__dict__[key] = value def __delitem__(self, key): print('__delitem__ obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('__delattr__ obj.key时,我执行') self.__dict__.pop(item) item类的方法,都有默认返回值,如果不定义return 的,默认就是 return none 使用的方式也是类似字典的形式,不再是类属性的方式,也就是不能使用. 需要使用成test4[&#39;new&#39;] = &#39;test555&#39;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlchemy 和 flask-SQLAlchemy区别]]></title>
    <url>%2F2018%2F05%2F31%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fsqlchemy%20%E5%92%8C%20flask-SQLAlchemy%2F</url>
    <content type="text"><![CDATA[sqlchemy 和 flask-SQLAlchemy flask-sqlalchemy 是针对sqlalchemy进行了一些封装，使得它更适合flask的使用 数据库初始化 mysql://root:starcor@127.0.0.1:3306/publish_platform_1_3_0?charset=utf8 在 create_engine 的时候,设置连接数据库使用 utf8的模式 初始化一个表,使用__table_args__, 1__table_args__ = &#123;'mysql_engine':'InnoDB','mysql_charset': 'utf8'&#125; 其他设置请看 详细设置 flask-sqlalchemy中的relationship方法 主要语法结构是db.relationship(&quot;MainMoreMapper&quot;, backref=&quot;new_role&quot;, lazy=&quot;dynamic&quot;)这不是实际的数据库字段，而是用户和其动态之间关系的高级视图，因此它不在数据库图表中。对于一对多关系，db.relationship字段通常在“一”的这边定义，并用作访问“多”的便捷方式。因此，如果我有一个用户实例u，表达式u.posts将运行一个数据库查询，返回该用户发表过的所有动态。 db.relationship的第一个参数表示代表关系“多”的类。 backref参数定义了代表“多”的类的实例反向调用“一”的时候的属性名称。这将会为用户动态添加一个属性post.author，调用它将返回给该用户动态的用户实例。 lazy参数定义了这种关系调用的数据库查询是如何执行的 最重要的一点就是可以使用MainMOreMapper的实力对象获取到设置这个关系的表的所有数据 例如A，B两个表，A中有relationship，B中有外键，指向的是A，那么可以通过B的这个外键访问对应的A中的数据 first和first_or_404的用法区别 两者都是数据库对象的查询方法，只不过后者多了一个查询不到就返回404给客户端的操作 返回的404操作会造成浏览器查询不到url的状况，也就是说可以用来判断用户登录时，自己的个人主页，如果用户不存在，那么就直接返回错误的url，url必须是带有用户id字段的参数]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis注意点]]></title>
    <url>%2F2018%2F05%2F31%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fredis%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[redis需要注意的点合理使用集合类 ZRANGEBYSCORE和ZREMRANGEBYSCORE命令的时间复杂度是 O(log(N) + M)，其中M是操作的元素个数，N是集合元素总数 当一次性查询的量特别大的时候，需要分批次查询 可以通过缩小每次查询的集合数量，可以将一天分成多段，分批次查询，比如把查24小时范围的用户改为查4小时范围的用户，分别查6次处理即可。 如果一天都是很大，那么颗粒度可以更小，按小时，分钟数都可以 注意 使用 sortedset、set、list、hash等集合类的O(N)操作时要评估当前元素个数的规模以及将来的增长规模，对于短期就可能变为大集合的key，要预估O(N)操作的元素数量，避免全量操作，可以使用HSCAN、SSCAN、ZSCAN进行渐进操作。集合元素数量过大在使用过程中会影响redis的实际性能，元素个数建议尽量不要超过5000，元素数量过大可考虑拆分成多个key进行处理。 合理设置到期时间 需要对key加上过期时间，否则，一直生成的key会导致慢日志，如果使用不是需要全部的数据，那么就应该只找最相应的数据，如果全部需要应该落实到mysql等关系型数据库中 注意 如果key没有设置超时时间，会导致一直占用内存。对于可以预估使用生命周期的key应当设置合理的过期时间或在最后一次操作时进行清理，避免垃圾数据残留redis 合理使用批操作命令 一次性导入上万个数据的时候，不应该使用for循环来执行hset的操作，这样会导致接口响应超时使用hmset一次性将元素都导入进去，也会导致慢日志 注意 对于大量频繁的hset操作可以使用 HMSET替代减少redis操作次数同时提升处理速度，但是要考虑单次请求操作的数量，避免慢日志。在redis使用过程中，要正视网络往返时间，合理利用批量操作命令，减少通讯时延和redis访问频次。redis为了减少大量小数据CMD操作的网络通讯时间开销 RTT (Round Trip Time)，支持多种批操作技术： MSET/HMSET等都支持一次输入多个key，LPUSH/RPUSH/SADD等命令都支持一次输入多个value,也要注意每次操作数量不要过多,建议控制在500个以内； PipeLining 模式 可以一次输入多个指令。redis提供一个 pipeline 的管道操作模式，将多个指令汇总到队列中批量执行，可以减少tcp交互产生的时间，一般情况下能够有10%~30%不等的性能提升； 更快的是Lua Script模式，还可以包含逻辑。redis内嵌了 lua 解析器，可以执行lua 脚本，脚本可以通过eval等命令直接执行，也可以使用script load等方式上传到服务器端的script cache中重复使用。 减少不必要的请求 某业务系统，当用户进入某个页面时会同时请求多个接口，每个接口都会校验用户状态是否有效，用户状态存在redis里并设置有过期时间，对于key未过期但是过期时间大于指定阈值的，需要重新设置有效时间，否则需要使用del命令删除掉。但是部分key由于过期其实已经不存在了，所以出现部分无效del命令。用户越多，就会有越多的无效命令。 ttl命令对于key不存在的情况会返回-2，若key不存在则不需要再调用del命令，可减少无效请求。 注意 edis的所有请求对于不存在的key都会有输出返回，合理利用返回值处理，避免不必要的请求，提升业务吞吐量。 避免value设置过大 某开发人员将一个商品集合信息序列化后用redis的字符串类型存储，使用的时候再反序列化成对象列表使用，大小超过1MB，在网络传输的时候由于数据比较大会触发拆包，会降低redis的吞吐量。 数量比较多时可以考虑改用hash结构存储，每一个field是商品id,value是该商品对象，如果数量较大可使用hscan获取。 注意 String类型尽量控制在10KB以内。虽然redis对单个key可以缓存的对象长度能够支持的很大，但是实际使用场合一定要合理拆分过大的缓存项，1k 基本是redis性能的一个拐点。当缓存项超过10k、100k、1m性能下降会特别明显。关于吞吐量与数据大小的关系可见下面官方网站提供的示意图。 设计规范的key名 保持简洁性 以业务名为前缀，用冒号分隔，可使用业务名：子业务名：id的结构命名，子业务下多单词可再用下划线分隔举例：活动系统-人拉人红包活动-id，可命名为 ACTIVITY:INVITE_REDPACKET:001 保持简洁性 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视 不含转义字符 不包含空格、换行、单双引号以及其他转义字符 留心禁用命令 keys、monitor、flushall、flushdb应当通过redis的rename机制禁掉命令，若没有禁用，开发人员要谨慎使用。其中flushall、flushdb会清空redis数据；keys命令可能会引起慢日志；monitor命令在开启的情况下会降低redis的吞吐量，根据压测结果大概会降低redis50%的吞吐量，越多客户端开启该命令，吞吐量下降会越多。 keys和monitor在一些必要的情况下还是有助于排查线上问题的，建议可在重命名后在必要情况下由redis相关负责人员在redis备机使用，monitor命令可借助redis-faina等脚本工具进行辅助分析，能更快排查线上ops飙升等问题。]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq常用]]></title>
    <url>%2F2018%2F05%2F31%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Frabbitmq%2F</url>
    <content type="text"><![CDATA[rabbitmq#personal/技术储备/rabbitmq RabbitMQ是一个消息代理 - 一个消息系统的媒介。它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。RabbitMQ中文文档 · RabbitMQ in Chinese 持久化 队列持久化 1channel.queue_declare(queue='hello', durable=True) 消息持久化 1delivery_mode = 2 以上代码只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用fsync(2)——它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务 交换机 扇形交换机fanout 主要用来一对多。消息发送到多个队列，通过队列绑定到交换机来换成 12345678# exchange后接交换机名，type表明交换机类型；# 每次均需要申明队列名ch.exchange_declare(exchange='test', type='fanout')ch.queue_declare(queue='a')ch.queue_declare(queue='b')# 绑定队列到test这个交换机中ch.queue_bind(exchange='test', queue='a')ch.queue_bind(exchange='test', queue='b') direct 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列 123456789channel.exchange_declare(exchange='direct_logs',type='direct')channel.basic_publish(exchange='direct_logs', routing_key=severity, body=message)# 处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定for severity in severities: channel.queue_bind(exchange='direct_logs', queue=queue_name, routing_key=severity) topic 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列 * (星号) 用来表示一个单词. # (井号) 用来表示任意数量（零个或多个）单词。123456channel.exchange_declare(exchange='topic_logs', type='topic')routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else 'anonymous.info'channel.basic_publish(exchange='topic_logs', routing_key=routing_key, body=message) 接受消息12345678910channel.exchange_declare(exchange='topic_logs', type='topic')result = channel.queue_declare(exclusive=True)queue_name = result.method.queuebinding_keys = sys.argv[1:]for binding_key in binding_keys: channel.queue_bind(exchange='topic_logs', queue=queue_name, routing_key=binding_key) callback123456789101112channel.basic_publish(exchange='', routing_key='task_queue', body=message, properties=pika.BasicProperties( delivery_mode = 2, # make message persistent ))channel.basic_consume(callback, queue='task_queue')channel.start_consuming()]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitignore的例子]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fgit%2F</url>
    <content type="text"><![CDATA[git .gitignore 去掉没必要加入暂存区的文件以及目录，例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195# Byte-compiled / optimized / DLL files__pycache__/*.py[cod]*$py.class# C extensions*.so# Distribution / packaging.Pythonenv/build/develop-eggs/dist/downloads/eggs/.eggs/lib/lib64/parts/sdist/var/*.egg-info/.installed.cfg*.egg# PyInstaller# Usually these files are written by a python script from a template# before PyInstaller builds the exe, so as to inject date/other infos into it.*.manifest*.spec# Installer logspip-log.txtpip-delete-this-directory.txt# Unit test / coverage reportshtmlcov/.tox/.coverage.coverage.*.cachenosetests.xmlcoverage.xml*,cover.hypothesis/# Translations*.mo*.pot# Django stuff:*.loglocal_settings.py# Flask instance folderinstance/# Scrapy stuff:.scrapy# Sphinx documentationdocs/_build/# PyBuildertarget/# IPython Notebook.ipynb_checkpoints# pyenv.python-version# celery beat schedule filecelerybeat-schedule# dotenv.env# Spyder project settings.spyderproject.idea/#mac.DS_Storedb.sqlite3### Node #### Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# nyc test coverage.nyc_output# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modulesjspm_packages# Optional npm cache directory.npm# Optional REPL history.node_repl_history### Vim #### swap[._]*.s[a-w][a-z][._]s[a-w][a-z]# sessionSession.vim# temporary.netrwhist*~# auto-generated tag filestags### PyCharm #### Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839# User-specific stuff:.idea/workspace.xml.idea/tasks.xml.idea/dictionaries.idea/vcs.xml.idea/jsLibraryMappings.xml# Sensitive or high-churn files:.idea/dataSources.ids.idea/dataSources.xml.idea/dataSources.local.xml.idea/sqlDataSources.xml.idea/dynamic.xml.idea/uiDesigner.xml# Gradle:.idea/gradle.xml.idea/libraries# Mongo Explorer plugin:.idea/mongoSettings.xml## File-based project format:*.iws## Plugin-specific files:# IntelliJ/out/# mpeltonen/sbt-idea plugin.idea_modules/# JIRA pluginatlassian-ide-plugin.xml# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.propertiesfabric.properties### PyCharm Patch #### Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721# *.iml# modules.xml# .idea/misc.xml# *.ipr# django static filesstatic/]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue和jquery的比较]]></title>
    <url>%2F2018%2F05%2F31%2F5%E5%89%8D%E7%AB%AF%2Fvue%2Fvuejs%2F</url>
    <content type="text"><![CDATA[vuejs 和jquery的比较 jquery属于结构驱动，$(‘dom’).text = “hello, world”vuejs属于数据驱动，this.msg = “hello, world”]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云部署centos]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2F%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2-Centos%2F</url>
    <content type="text"><![CDATA[阿里云部署-Centos#Personal# Git yum install git，查看git版本 clone库，需要带上用户名，例如git clone https://mashpolo@git.coding.net/mashpolo/sdk.git MySQL yum install mysql-server 创建账号密码—mysqladmin -uroot password “xxx” service mysqld start Redis yum install redis service redis start MySQLdb yum install MySQL-python]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用]]></title>
    <url>%2F2018%2F05%2F31%2F1%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql#personal/技术储备/mysql mysql编码格式 show variables like ‘%char%’查看该数据库中所有的编码格式，需要修改的话，直接set xxx=utf8 注意 该情况只能临时生效，具体的需要修改my.cnf配置文件中来修改 truncate table table_name 删除连带主键在内的所有表数据仅仅用delete，新增的数据，主键还会依次增加，这个命令会重新生成新的主键排序 在 mysql的命令行中，敲错命令，利用后面\c取消该条命令distinct 查询某个表里面不重复的数据12345678910mysql&gt; select distinct flags from items;+-------+| flags |+-------+| 0 || 1 || 2 || 4 |+-------+4 rows in set (0.00 sec) 导出数据库表结构或者数据 导出數據库為dbname所有表结构及表數據（不加-d） mysqldump -uroot -pdbpasswd dbname table_name&gt;db.sql;导出數據库為dbname某张表(test)结构 (加 -d) mysqldump -uroot -pdbpasswd -d dbname table_name&gt;db.sql; mysql中的编码问题 编码格式如果没有定义，都是继承关系，mysql设置-&gt;database的编码-&gt;表结构的编码-&gt;表字段的编码 查看数据库的默认编码 show variables like &#39;%char%&#39; 强制设置数据库的默认编码使用set，一般修改的result的编码，直接使用 set names utf8 查看具体某个数据库的编码格式 SHOW CREATE DATABASE nn_publish_platform; 修改数据库的编码 alter database name character set utf8; 查看表里面具体字段的编码 SELECT CHARACTER_SET_NAME, COLLATION_NAME FROM information_schema.COLUMNS WHERE TABLE_NAME=&quot;monitor_templates&quot;; 修改表里面具体字段的编码 ALTER TABLE test_table ADD COLUMN char_column VARCHAR(25) CHARACTER SET utf8; 要替换表结构中的数据 比如A 表中 C1的数据为’master’, 需要在前面加一个 code, 可以使用CONCAT方法来操作 12update A set C1=CONCAT('code', C1); //在前面加update A set C1=CONCAT('test', C1, 'asgasdg'); //前后都加 替换表数据 比如要替换 A 表中的 C1的数据为’master’, 需要改为’ mazasster’, 使用replace 方法 1update A set C1=replace(C1, 'master', 'mazasster')]]></content>
      <tags>
        <tag>存储关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的异常处理]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[python中的异常python使用print直接打印json.dumps，利用supervisor写入文件报错编码问题 unicode编码的内容无法直接写入文件，需要转成utf8]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的namedtuple使用详解]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2F15302580663353%2F</url>
    <content type="text"><![CDATA[collections中的namedtuple 是一个具名元组，生成了一个简单的属性类 继承自tuple对象，并且赋予的属性都是只读的 1234567import collectionsCard = collections.namedtuple('Card', ['rank', 'suit'])//结果如下//In [51]: Card('test', 'test3')//Out[51]: Card(rank='test', suit='test3') python中的类的内置特殊方法并没有getitem方法，这个是可以将类转换成一个列表来获取类中的对象个数 所有列表中的特性都可以试用的，也就是说不仅仅是获取类中元素的个数，包括切片都是可以的 可以迭代，也就是说已经转换成了一个可迭代对象，反向迭代也是可以的 通过对object类增加len，getitem的方法，使之支持python的序列数据结构特性 12345678910111213141516171819202122232425262728293031323334import collectionsCard = collections.namedtuple('Card', ['rank', 'suit'])class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position]deck = FrenchDeck()print(deck._cards[23])print(len(deck))print(deck[0])print(deck[:3])//结果如下://Card(rank='Q', suit='diamonds')//52//Card(rank='2', suit='spades')//[Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')] 随机抽取可以使用random类中的choice方法，已经造好了轮子，可以直接使用的 1234567891011from random import choiceprint(choice(deck))print(choice(deck))print(choice(deck))print(choice(deck))//Card(rank='J', suit='hearts')//Card(rank='K', suit='diamonds')//Card(rank='K', suit='clubs')//Card(rank='3', suit='hearts') namedtuple最重要的几个专有属性 _fields属性 类方法 _make(iterable) 实例方法 _asdict()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本的数据结构理解]]></title>
    <url>%2F2018%2F05%2F31%2F6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基本的数据结构理解数组 存储有序的对象 从0开始的索引 优点：快速查询，快速排序，以及append都是o(1)的时间度 缺点：大小是固定的，利用索引来插入，删除数据的话，是o(n)的时间复杂度 阅读资料 动态数组 可变数组，python中的列表就类似这种数据形式 可以自动调节大小 主要就是不必要在定义数组之前就设定大小，它会根据你值的长度来重新定义数组的大小 优点：可变的大小，快速查询 缺点：append，delete，insert操作很费时，o(n)的时间复杂度 阅读资料 链表 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1) 元素在链表中被称作节点，头节点被称为head，尾节点被称为tail 和顺序表不同，在内存中存储的位置，相邻的数据并不是挨着的 优点：在头尾操作都很快，可变的大小 缺点：查询需要花费大量时间 阅读资料 队列 先进先出的概念 优点：所有的操作都是很快的，o(1) 阅读资料 栈 后进先出的概念 优点：操作都是很快的，o(1) 阅读资料 哈希表 也就是python中的字典概念 关系表，map的感念 优势：快速的查询里面的元素，可变的键值，自由增长 缺点：无序的，比如要查找其中最小的键，必须遍历整个哈希表；要查询指定键的值，也需要遍历整个表；都是o(n) 阅读资料 树 有层次的数据结构，每个元素都是一个节点，每个节点可以连接n个节点，n&gt;=0 叶节点指的是最底层的节点，后面没有节点与它相连了，个数也就是最下面元素的个数 高度指的是最底层的节点到根部的距离 查找分为广度优先和深度优先 详细资料 二叉查找树 是一个有一定规则的二叉树 左边的节点一定比当前的节点小，右边的节点一定比当前的节点大 优势：整体表现更好，广度优先算法是可以排序的 缺点：如果该树不是平衡的，表现很差；没有o(1)的操作，最少都是o(log(n)) 详细资料 图 网路中的节点组成图 每个节点都是通过边缘连接 优势：展示了每个节点的连接关系 缺点：扩展很费时间 详细资料]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的退出]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E9%80%80%E5%87%BA%2F</url>
    <content type="text"><![CDATA[python中的退出sys.exit(n) 异常，可以通过try…except…捕获 n的默认值为0，一般在主程序中使用 os._exit() 直接退出解释器，无法执行后面的代码，不能捕获异常 常用在子进程的退出 exit()/quit() SystemExit异常. 一般在交互式shell中退出时使用]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养]]></title>
    <url>%2F2018%2F05%2F31%2F3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%2F</url>
    <content type="text"><![CDATA[程序员的自我修养#personal/读书笔记/程序员的自我修养 计算机基础 计算机最主要的功能件 cpu，内存，I／O设备 多任务系统是为了方便cpu切换不同任务的所占内存，时间一旦设置的比较小，那么就可以认为是并行的 所有的计算机问题都可以增加一个中间层来解决 硬件以及硬件接口— 最底层 运行库以及驱动 — 中间层 应用程序编程接口以及应用程序或开发工具 — 最上层 操作系统最主要的目的是提供应用程序的接口以及管理硬件资源 物理内存地址以及虚拟内存地址 为了保障任务之间的不干扰以及对内存的更优化使用，物理内存与虚拟内存地址是一一对应的分段和分页方法，分页优于分段，分段是按照任务，内存满后，将一个任务写入磁盘来获取新的内存空间；分页是将单个任务再次细分衍生出进程的概念 磁盘按照扇区-&gt;磁道-&gt;盘面-&gt;磁盘]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python执行linux系统命令]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E6%89%A7%E8%A1%8Clinux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[python执行linux系统命令os.system(cmd) 返回的是一串数字，执行成功的数字是0，执行失败是大于0的数字 os.popen(cmd) 返回系统执行命令的结果 commands模块 commands.getoutput(cmd) commands.getstatusoutput(cmd)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python为什么慢]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E7%9B%B8%E8%BE%83%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BD%8E%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[python相较其他语言，性能低？ 相较于一些其他的静态，编译语言，例如java，c，c#，c++等等，python是其中性能最差的这一，从以下几个方面来分析为什么python执行这么慢 GIL锁 现代计算机的CPU有多个内核，有时还有多个处理器。为了利用所有这些额外的处理能力，操作系统定义了一个称为线程的底层结构，在这个结构中，一个进程(如Chrome浏览器)可以产生多个线程，并在其中为系统提供指令。这样，如果一个进程是cpu密集型的，那么该负载可以跨内核共享，从而有效地使大多数应用程序更快地完成任务。 cpython创建一个变量的时候，会根据该对象有多少引用记录来分配内存，如果引用是0的个数，那么就代表该内存会被清除掉 python中的web app框架，每个请求都是一个单独的解释器来运行的，所以每次请求都有一个锁 JavaScript的事件循环和回调模式是异步编程代替并发实现的方式。Python与asyncio事件循环有相似之处。 因为python是一门解释性的语言 每次cpython运行一个程序，CPython将开始一系列的读取、试错、解析、编译、解释和执行代码，并且每次都会重新生成一个.pyc的文件，所以每次执行程序，cpython都会实时重新完成上面的步骤JIT(just in time)的编译机制，java有一个自己的虚拟编译系统，但每次加载都会很慢。但是，第一次执行完后，后面的加载都会非常快AOT(ahead of time)的编译机制，c，c++的语言机制，表明必须让cpu明白每一行代码的意义，然后再开始用解释器来执行pypy有JIT，但cpython开始调用解释器就很慢了，pypy会更慢 因为python是一门动态语言 动态语言的定义在于，赋值变量之前，不需要申明变量的类型，解释器会根据变量值来自行判断用什么类型来存储cpython是放弃了优化性能的空间来保持高度的灵活性 总结 但是，有一些方法可以通过利用异步、理解分析工具并考虑使用多解释器来优化Python应用程序对于一些应用，如果不在乎它的启动时间，那么可以使用pypy的方式，会比cpython更优效率对于性能非常重要且具有更多静态类型变量的代码部分，请考虑使用Cython 详细资料]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js不需要返回地址]]></title>
    <url>%2F2018%2F05%2F31%2F5%E5%89%8D%E7%AB%AF%2Fjs%2Fjs%20%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20url%20%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[js 不需要返回一个 url 地址 在a标签中,如果需要返回一个空的 url 地址,那么url需要是一个空值当浏览器打开 javascript: URI 的时候，它会首先运行 URI 中的代码，然后将当前页面整个替换为这段代码的返回值，除非该返回值是 undefined 12&lt;a href="javascript:;"&gt;&lt;/a&gt;&lt;a href="javascript:void(0)"&gt;&lt;/a&gt; 上面两个是等价的,也就是返回下面的写法 1&lt;a href="#" onclick="return false;"&gt;href&lt;/a&gt;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-canvas生成图片]]></title>
    <url>%2F2018%2F05%2F31%2F5%E5%89%8D%E7%AB%AF%2Fnodejs%2Fnode-canvas%E6%A8%A1%E5%9D%97%E5%9C%A8centos6%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node-canvas模块在centos6上的安装 首先需要升级gcc的版本 中间node-gyp rebuild依然报错，所以加入依赖包 成功 1234567891011# 加入gcc高等级的源wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo# 下载gcc4.8yum --enablerepo=testing-devtools-2-centos-6 install devtoolset-2-gcc devtoolset-2-gcc-c++# node-gyp rebuild报错# centos6，gcc 4.8.2下出现expecting string instruction after `rep’# 下载依赖包yum install devtoolset-2-gcc devtoolset-2-binutils# 进入下载的node-canvas源码库node-gyp rebuild# 成功就代表安装完成，目录下方已经包含有build目录了]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-echarts模块]]></title>
    <url>%2F2018%2F05%2F31%2F5%E5%89%8D%E7%AB%AF%2Fnodejs%2Fnode-echarts%2F</url>
    <content type="text"><![CDATA[node-echarts https://github.com/suxiaoxin/node-echarts 图片包含中文，需要有canvas这个模块包 centos6上，需要单独编译源码包 都完成后，不再使用npm install canvas，直接使用源码 123// 替换// require("canvas")require("/path/node-canvas")]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的爬虫框架介绍]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fscrapy%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[scrapy 爬虫框架简介命令行参数 启动一个新的爬虫项目 scrapy startproject smzdm 创建一个新的spider scrapy genspider domain domain.com 在 spider 目录下创建domain 的文件,代码如下 进入命令行模式,直接爬取一个 url, 并返回结果对象 scrapy shell xxx-url 开始执行爬虫项目 scrapy crawl smzdm, 必须在项目中执行语句 查看该项目中的具体爬虫有哪些 scrapy list, 必须在项目中执行语句 直接打开编辑器修改某一个具体的 spider, scrapy edit smzdm, 必须在项目中执行语句 查看spider如何获取某个特定页面,排查爬虫看到的页面是否就是我们浏览器看到的页面, scrapy view xxx-url 使用Scrapy下载器(downloader)下载给定的URL，并将获取到的内容送到标准输出, scrapy fetch xxx-url 在未创建项目的情况下，运行一个编写在Python文件中的spider, scrapy runspider xxx.py 查看 scrapy 版本, scrapy version -v, 配合 -v运行时，该命令同时输出Python, Twisted以及平台的信息 item 类似 flask 中的 model 模块,用来定义爬取下来的数据分类 12345class SmzdmItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() good = scrapy.Field() price = scrapy.Field() spider 爬虫的主体,用来爬取 url, 并返回页面的数据对象,根据 xpath 来解析,默认使用 parse 方法来回调 123456789101112class MySpider(scrapy.Spider): name = "smzdm" start_urls = ["http://search.smzdm.com/?c=faxian&amp;s=Nintendo Switch&amp;v=a"] def parse(self, response): # We want to inspect one specific response. items = response.xpath("//div/ul[@id='feed-main-list']/li") for item in items: info = SmzdmItem() info["good"] = item.xpath(".//h5[@class='feed-block-title']/a/text()").extract_first() info["price"] = item.xpath(".//a/div[@class='z-highlight']/text()").extract_first() yield info pipeline 主要用来区分 parse 方法解析出来的数据,进行下一步的操作,比如说筛选,存入数据库等 12345678class SmzdmPipeline(object): def __init__(self): self.file = open('items', 'wb') def process_item(self, item, spider): line = item['good'].strip() + ":" + item['price'] + '\n' print(line)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor简单使用]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fsupervisor%2F</url>
    <content type="text"><![CDATA[supervisor 安装supervisor pip install supervisor 注意报错：pkg_resources.DistributionNotFound: meld3&gt;=0.6.5,需要升级setuptools pip install -U setuptools echo_supervisord_conf &gt;/etc/supervisord.conf 生成配置文件 mkdir /etc/supervisord.d/ 生成配置目录 在supervisord.conf文件中，加入以下内容 12[include]files = /etc/supervisord.d/*.conf]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[traceback简单使用]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Ftraceback%2F</url>
    <content type="text"><![CDATA[traceback -p 进程号查看该进程的底层执行情况，判断该进程是否出问题，卡在什么地方]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim保存只读]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fvim%2F</url>
    <content type="text"><![CDATA[vim使用大写的 W 来保存 root 权限的 filecommand W :execute &#39;:silent w !sudo tee % &gt; /dev/null&#39; | :edit! 将上面的命令存入 vimrc 文件中,当使用 vim 打开文件的时候,就可以直接使用 W 来保存当前账户无法保存,但 sudo 可以保存的修改了]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[guetzti]]></title>
    <url>%2F2018%2F05%2F31%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2FGuetzli%2F</url>
    <content type="text"><![CDATA[Guetzli 压缩图片 https://github.com/google/guetzli/]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的数据库对象经常失效]]></title>
    <url>%2F2018%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fsession%E7%9A%84%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E4%BB%8E%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%85%A5celery%E4%B8%AD%E7%9A%84db%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[session的关闭导致从接口传入celery中的db对象无法使用 由于接口中调用了另外的模块，执行了session.commit操作，导致从接口中传入celery中的变量带有db的对象无法使用解决的办法只有，讲db对象转化成dict或者其他的数据结构，或者能想办法将之转化成普通的对象也可以使用]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的编码和解码]]></title>
    <url>%2F2018%2F04%2F21%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python中的编码以及解码 所有的字符串的中间编码格式都可以是unicode，这样转换起来更加的快捷和方便 格式12 decode encodebase ------------&gt; unicode -------&gt; other 假设a是一个ISO-8859-2编码的字符串，想要转换成utf8，那么首先要先解码成unicode，在转码 12345678910import chardeta='\xc7\xeb\xb5\xc7\xc2\xbcexmail.qq.com\xd0\xde\xb8\xc4\xc3\xdc\xc2\xeb'In [21]: chardet.detect(a)Out[21]: &#123;'confidence': 0.30158743562616186, 'encoding': 'ISO-8859-2'&#125;In [28]: print a.decode('ISO-8859-2')ÇëľÇÂźexmail.qq.comĐŢ¸ÄĂÜÂëIn [34]: s.encode('utf8')Out[34]: '\xc3\x87\xc3\xab\xc4\xbe\xc3\x87\xc3\x82\xc5\xbaexmail.qq.com\xc4\x90\xc5\xa2\xc2\xb8\xc3\x84\xc4\x82\xc3\x9c\xc3\x82\xc3\xab']]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的字符串替换]]></title>
    <url>%2F2018%2F03%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[python中的字符串替换 %的替换法则 可以用如下的方式，对格式进行进一步的控制：%[(name)][flags][width].[precision]typecode (name)为命名 flags可以有+,-,&#39; &#39;或0。+表示右对齐。-表示左对齐。&#39; &#39;为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。 width表示显示宽度 precision表示小数点后精度 1print '%05d' % 812 #00812 5位的数字，不够数字那么就用0补齐，用0补全了不够的位数，超过位数就是替换的字符本身 %r和%s的区别 %r用rper()方法处理对象 %s用str()方法处理对象 %r打印时能够重现它所代表的对象 123456789101112131415161718print("hello,world. %s" % 22)print("hello,world. %r" % 22)print("hello, str. %s" % 'just test')print("hello, str. %r" % 'just test')import datetimed = datetime.date.today()print("%s" % d)print("%r" % d)### results:hello,world. 22hello,world. 22hello, str. just testhello, str. 'just test'2018-05-22datetime.date(2018, 5, 22) format 和 %s 格式化字符串 format方法更加优秀，使用的范围更广，更彻底 123456789101112131415161718192021print("网站名：&#123;name&#125;, 地址 &#123;url&#125;".format(name="菜鸟教程", url="www.runoob.com"))# 通过字典设置参数site = &#123;"name": "菜鸟教程", "url": "www.runoob.com"&#125;print("网站名：&#123;name&#125;, 地址 &#123;url&#125;".format(**site)) # 通过列表索引设置参数my_list = ['菜鸟教程', 'www.runoob.com']print("网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;".format(my_list)) # "0" 是必须的``` # python中的恢复原数据的类型&gt; ast.literal_eval()```pythonIn [1]: import astIn [2]: a='[1,2,3]'In [3]: ast.literal_eval(a)Out[3]: [1, 2, 3] 注意 相较于eval而言，该方法会判断需要计算的内容计算后是不是合法的python类型，如果是则进行运算，否则就不进行运算]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F11%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fphantomjs%2F</url>
    <content type="text"><![CDATA[title: 使用phantomjs截取网页中文乱码解决办法date: 2017-05-31 22:21:02tags: pythondescription: &gt; 使用phantomjs截取网页中文乱码解决办法 phantomjs 截图中文乱码 yum install bitmap-fonts bitmap-fonts-cjk]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python恢复sqlalchemy的数据]]></title>
    <url>%2F2017%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E4%B8%AD%E4%BD%BF%E7%94%A8sqlalchemy%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Cmigration%E7%9B%AE%E5%BD%95%E8%A2%AB%E5%88%A0%E9%99%A4%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[python中使用sqlalchemy的时候，migration目录被删除如何恢复 对应的数据库中有一个alembic_version表，里面有一条version的记录，需要将这个表的数据清空 重新执行init，migrate以及upgrade的操作，就可以完整恢复]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用数据库]]></title>
    <url>%2F2017%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fsqlchemy%20%E5%92%8C%20flask-SQLAlchemy%2F</url>
    <content type="text"><![CDATA[sqlchemy 和 flask-SQLAlchemy flask-sqlalchemy 是针对sqlalchemy进行了一些封装，使得它更适合flask的使用 数据库初始化 mysql://root:starcor@127.0.0.1:3306/publish_platform_1_3_0?charset=utf8 在 create_engine 的时候,设置连接数据库使用 utf8的模式 初始化一个表,使用__table_args__, 1__table_args__ = &#123;'mysql_engine':'InnoDB','mysql_charset': 'utf8'&#125; 其他设置请看 详细设置 flask-sqlalchemy中的relationship方法 主要语法结构是db.relationship(&quot;MainMoreMapper&quot;, backref=&quot;new_role&quot;, lazy=&quot;dynamic&quot;)这不是实际的数据库字段，而是用户和其动态之间关系的高级视图，因此它不在数据库图表中。对于一对多关系，db.relationship字段通常在“一”的这边定义，并用作访问“多”的便捷方式。因此，如果我有一个用户实例u，表达式u.posts将运行一个数据库查询，返回该用户发表过的所有动态。 db.relationship的第一个参数表示代表关系“多”的类。 backref参数定义了代表“多”的类的实例反向调用“一”的时候的属性名称。这将会为用户动态添加一个属性post.author，调用它将返回给该用户动态的用户实例。 lazy参数定义了这种关系调用的数据库查询是如何执行的 最重要的一点就是可以使用MainMOreMapper的实力对象获取到设置这个关系的表的所有数据 例如A，B两个表，A中有relationship，B中有外键，指向的是A，那么可以通过B的这个外键访问对应的A中的数据 first和first_or_404的用法区别 两者都是数据库对象的查询方法，只不过后者多了一个查询不到就返回404给客户端的操作 返回的404操作会造成浏览器查询不到url的状况，也就是说可以用来判断用户登录时，自己的个人主页，如果用户不存在，那么就直接返回错误的url，url必须是带有用户id字段的参数]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的列表推导]]></title>
    <url>%2F2017%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2F%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[列表推导 py2中的列表推导式，使用的变量是全局的；py3中的列表推导式，生成器推导，set推导，dict的推导都是使用的局部变量域 py的括号中，可以省略使用换行符 12345678## python3In [105]: a='hello'In [106]: [a for a in 'ABC']Out[106]: ['A', 'B', 'C']In [107]: aOut[107]: 'hello' 12345678## python2In [1]: a='hello'In [2]: [a for a in 'ABC']Out[2]: ['A', 'B', 'C']In [3]: aOut[3]: 'C' 生成器推导 和列表推导的语法结构一样，只是用小括号]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh-key 登陆]]></title>
    <url>%2F2017%2F02%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fssh-key%20%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[ssh-key 登陆 ssh-copy-id -i .ssh/id_rsa.pub root@xxxx 使用前提是远程服务器的.ssh目录权限要正确 root的权限必须是root:root（当登陆的是root用户的时候尤其重要） 目标log文件地址: /var/log/secure Authentication refused: bad ownership or modes for directory /root出现上面的错误，即 12chmod 0750 /root -R#chown root.root root 禁止密码登录 centos 6.* 修改 /etc/ssh/sshd_config文件 PasswordAuthentication ： no ChallengeResponseAuthentication : no PubkeyAuthentication: yes 重启sshd服务，/etc/init.d/sshd restart #personal/技术储备/ssh登陆]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell管道]]></title>
    <url>%2F2017%2F02%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fshell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[shell脚本中的管道 想在shell的脚本中使用命令，命令中带有管道的话，不能直接执行，需要在命令前面加入eval，这样才能正常执行下去]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl用法]]></title>
    <url>%2F2017%2F02%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fcurl%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[curl获取接口数据#company/发布平台# 查询配置项某个文件下的配置项1curl -H "Authorization: Basic ZXlKaGJHY2lPaUpJVXpJMU5pSXNJbVY0Y0NJNk1UUTRPVGd6TVRBM05Td2lhV0YwSWpveE5EZzNNak01TURjMWZRLmV5SjFjMlZ5WDJsa0lqb3hmUS4tdVV4Y0l1ZENaakJXRTNwVWZqZHBYY0Rtb2dYTHFtZ1NndjJVeWhSSmFnOg==" http://139.224.235.47:8000/api/v1.0/publish/configs/2/files/content/test.php 添加配置项1curl -H "Authorization: Basic ZXlKaGJHY2lPaUpJVXpJMU5pSXNJbVY0Y0NJNk1UUTROak13TWpnNE15d2lhV0YwSWpveE5EZ3pOekV3T0RnemZRLmV5SjFjMlZ5WDJsa0lqb3hmUS5zZ3NMSTZkTFVBS2VVV2NTbEc3TV9RRmZEYkoybnQ5T2pJT2JCc2pZcmNzOg==" -H "Content-Type: application/json" -X POST -d '&#123;"name": "tset2", "value":"test2", "comment":"jst", "value_type":"special"&#125;' http://139.224.235.47:8000/api/v1.0/publish/configs/2/files/content/test.php 删除配置项1curl -H "Authorization: Basic ZXlKaGJHY2lPaUpJVXpJMU5pSXNJbVY0Y0NJNk1UUTROak13TWpnNE15d2lhV0YwSWpveE5EZ3pOekV3T0RnemZRLmV5SjFjMlZ5WDJsa0lqb3hmUS5zZ3NMSTZkTFVBS2VVV2NTbEc3TV9RRmZEYkoybnQ5T2pJT2JCc2pZcmNzOg==" -H "Content-Type: application/json" -X DELETE -d '&#123;"name":["111"]&#125;' http://139.224.235.47:8000/api/v1.0/publish/configs/2/files/content/test.php]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos修改hostname]]></title>
    <url>%2F2017%2F02%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fcentos%E4%BF%AE%E6%94%B9hostname%2F</url>
    <content type="text"><![CDATA[centos修改hostname /etc/sysconfig/network]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash笔记]]></title>
    <url>%2F2017%2F02%2F09%2F7Linux%E5%91%BD%E4%BB%A4%E7%BA%A7%E5%88%AB%2Fbash%2F</url>
    <content type="text"><![CDATA[bashawk中的print和printf printf默认输出的结果不换行 print默认输出的结果和echo一样都是要换行的 echo语句默认是换行输出，使用”-n”选项可用实现不换行输出 判断字符串相等只能使用= 号，-ne只能用来判断是整数的不相等，-eq代表数字的相等注意尤其注意的是，判断字符串为空的时候，使用 12if [ -n $xxx ];then echo "test";fi #错误，无法判断if [ -n "$xxx" ];then echo "test";fi #正确的使用方法 shell中的if…elif…else…语句，后面不需要加: 号,加了以后，shell默认跳过这一行，会导致两个代码块的语句全部执行]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的安装]]></title>
    <url>%2F2015%2F05%2F31%2F2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AE%E9%A2%98%2Fpython%2Fpython%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[python安装centos6上安装pip yum install python-setuptools python-devel -y easy_install pip install MySQLdb 不能用pip安装 yum install MySQL-python MySQLdb fetchone和fetchlall 返回的结果类型不相同，fetchall返回的结果是元组里面还套了一层元组，而fetchone返回的直接就是一层元组结果 import futrue 引入未来版本的一些特性，需要将导入语句放在脚本第一行 需要提供百分比 from __future import division “%.2f%%” % (float_num_1/float_num_2*100)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
